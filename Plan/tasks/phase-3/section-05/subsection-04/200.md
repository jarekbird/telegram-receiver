# PHASE3-032: Analyze memory usage patterns

**Section**: 5. Performance Review
**Subsection**: 5.4
**Task ID**: PHASE3-032

## Description

Review and improve memory usage patterns in the codebase to ensure best practices. This task focuses on analyzing memory consumption, identifying potential memory leaks, reviewing object lifecycle management, and ensuring efficient memory usage throughout the application.

**Rails Implementation References:**

- `jarek-va/app/services/cursor_runner_service.rb` - Creates new HTTP connections per request (line 152: `Net::HTTP.new(uri.host, uri.port)`). **Issue**: No connection pooling/reuse. TypeScript implementation should use Axios with connection pooling or a shared HTTP agent.
- `jarek-va/app/services/telegram_service.rb` - Uses singleton pattern for bot client (`@bot ||= ...` on line 11). TypeScript should implement similar singleton/shared instance pattern for bot clients, but with per-token caching (Map keyed by token) for multi-bot support.
- `jarek-va/app/services/cursor_runner_callback_service.rb` - Creates Redis client per instance (line 20: `Redis.new(url: redis_url)`). **Issue**: Should use shared/pooled Redis connection. TypeScript implementation should use a shared Redis client instance (ioredis connection pool).
- `jarek-va/app/jobs/telegram_message_job.rb` - File cleanup patterns in `ensure` blocks (lines 341-351 for audio transcription, 378-388 for TTS). TypeScript should implement similar cleanup patterns using try/finally blocks to ensure temporary files are deleted.
- `jarek-va/app/jobs/telegram_message_job.rb` - Downloads files to temp directory and cleans up (line 333: `TelegramService.download_file`, cleanup in ensure block). TypeScript should ensure file streams are properly closed and temp files are cleaned up.

Reference the Rails implementation patterns where applicable to understand expected memory behavior and ensure the TypeScript implementation follows Node.js best practices for memory management.

## Checklist

### Memory Profiling and Monitoring

- [ ] Set up memory profiling tools
  - Configure Node.js memory profiling (e.g., `--inspect` flag, Chrome DevTools)
  - Set up heap snapshots for baseline and comparison
  - Configure memory monitoring in production (if applicable)
  - Review Node.js heap size limits and configuration
- [ ] Establish memory usage baselines
  - Measure baseline memory usage at application startup
  - Measure memory usage under normal load
  - Measure memory usage under peak load
  - Document memory usage patterns over time
- [ ] Monitor memory trends
  - Check for memory growth patterns (potential leaks)
  - Review memory spikes and their causes
  - Monitor heap size over extended periods
  - Track memory usage per service/module

### Object Lifecycle Management

- [ ] Review object creation patterns
  - Check for unnecessary object creation in hot paths
  - Review if objects can be reused or pooled
  - Identify objects created per request that could be shared
  - Check for object creation in loops
- [ ] Review object cleanup
  - Verify objects are properly dereferenced when no longer needed
  - Check for proper cleanup in error paths
  - Review cleanup in async operations (promises, callbacks)
  - Verify cleanup handlers are called (e.g., `finally` blocks)
- [ ] Review singleton and shared instances
  - Verify singletons are used appropriately (e.g., Redis client, HTTP clients)
  - Check that shared instances don't hold unnecessary state
  - Review if singletons prevent proper garbage collection
  - Verify shared instances are thread-safe/concurrent-safe

### Event Listener Management

- [ ] Review event listener registration
  - Check for event listeners that are never removed
  - Verify listeners are removed when objects are destroyed
  - Review Express middleware and route handlers for listener leaks
  - Check BullMQ worker event listeners
- [ ] Review event listener cleanup
  - Verify `removeListener` or `removeAllListeners` is called appropriately
  - Check for proper cleanup in error scenarios
  - Review cleanup in async operations
  - Verify listeners don't hold references to large objects
- [ ] Review closure references
  - Check if closures capture large objects unnecessarily
  - Verify closures don't prevent garbage collection
  - Review callback functions for memory retention
  - Check for circular references in closures

### Connection and Resource Management

- [ ] Review Redis connection management
  - **Rails Reference**: `jarek-va/app/services/cursor_runner_callback_service.rb` creates Redis client per instance (line 20). TypeScript should use a shared Redis client instance.
  - Verify Redis client uses connection pooling (ioredis connection pool, not creating new clients per request)
  - Check if Redis connections are properly closed on shutdown
  - Review connection reuse patterns (should use singleton/shared instance pattern)
  - Verify no connection leaks (connections not closed)
  - Check that all services (CallbackService, BullMQ workers) share the same Redis connection pool
- [ ] Review HTTP client connections (Axios)
  - **Rails Reference**: `jarek-va/app/services/cursor_runner_service.rb` creates new HTTP connections per request (line 152: `Net::HTTP.new`). TypeScript should use Axios with connection pooling.
  - Check if HTTP clients are reused (not created per request)
  - Verify Axios instance is shared across services (CursorRunnerService, TelegramService, ElevenLabs services)
  - Verify connection pooling is configured appropriately (HTTP keep-alive, maxSockets)
  - Review if connections are properly closed
  - Check for connection leaks in error scenarios
  - Verify Axios default instance or shared instance is used (not creating new instances per request)
- [ ] Review BullMQ queue and worker management
  - Verify workers are properly closed on shutdown
  - Check if queues hold references to completed jobs unnecessarily
  - Review job data retention (ensure completed jobs are cleaned up)
  - Verify workers don't accumulate state over time
- [ ] Review file and stream handling
  - **Rails Reference**: `jarek-va/app/jobs/telegram_message_job.rb` uses `ensure` blocks for file cleanup (lines 341-351, 378-388). TypeScript should use try/finally blocks.
  - Check if file streams are properly closed (use try/finally or stream.on('end') handlers)
  - Verify buffers are released after use (don't hold references to large buffers)
  - Review large file handling (e.g., Telegram file downloads - Rails downloads to temp dir and cleans up)
  - Check for stream leaks (streams not closed)
  - Verify temporary files are deleted after use (Rails pattern: download to temp, use, then delete in ensure block)
  - Review file download patterns (TelegramService.download_file downloads to temp directory - ensure cleanup)

### Large Object Retention

- [ ] Identify large objects in memory
  - Check for large buffers (e.g., audio files, images)
  - Review large data structures (arrays, objects)
  - Identify cached data that could be too large
  - Check for large strings or JSON objects
- [ ] Review large object lifecycle
  - Verify large objects are released when no longer needed
  - Check if large objects are held in closures or event listeners
  - Review if large objects can be streamed instead of buffered
  - Verify large objects aren't unnecessarily copied
- [ ] Review caching of large objects
  - Check if cache size limits are appropriate
  - Verify LRU eviction is working for large cached objects
  - Review if large objects should be cached at all
  - Check for memory pressure from large cached objects

### Garbage Collection Patterns

- [ ] Review garbage collection behavior
  - Check GC frequency and duration (using `--expose-gc` flag)
  - Review if objects are being collected appropriately
  - Identify objects that survive multiple GC cycles unnecessarily
  - Check for memory fragmentation
- [ ] Review weak references and weak maps
  - Check if WeakMap or WeakSet could replace Map/Set for better GC
  - Review if weak references are appropriate for certain use cases
  - Verify weak references don't prevent necessary object retention
- [ ] Review circular references
  - Check for circular references that prevent garbage collection
  - Verify circular references are broken when objects are no longer needed
  - Review if circular references are necessary or can be avoided

### Memory Leak Detection

- [ ] Identify common leak patterns
  - Check for global variables accumulating data
  - Review timers (setInterval/setTimeout) that aren't cleared
  - Check for event listeners that aren't removed
  - Review closures holding references to large objects
- [ ] Review service-level memory retention
  - **Rails Reference**: `jarek-va/app/services/telegram_service.rb` uses singleton pattern (`@bot ||= ...`). TypeScript should use per-token caching (Map) for multi-bot support.
  - Check TelegramService for retained state (bot client instances should be cached per token, not accumulate)
  - Review CursorRunnerService for retained state (should not hold HTTP connections or large request/response data)
  - Check CallbackService for retained callback state (should only store minimal data in Redis, not in-memory)
  - Verify services don't accumulate state over time (check for growing Maps/Objects that never clear)
  - Review singleton/shared instance patterns (ensure they don't accumulate data over time)
- [ ] Review request-level memory retention
  - Check Express middleware for retained request data
  - Review if request objects are held after response is sent
  - Verify request handlers don't accumulate state
  - Check for request context leaks

### Memory Optimization Opportunities

- [ ] Review data structure choices
  - Check if Map/Object size is appropriate for use case
  - Review if arrays could be replaced with more memory-efficient structures
  - Verify data structures don't waste memory (sparse arrays, etc.)
  - Check if data can be compressed or serialized more efficiently
- [ ] Review memory allocation patterns
  - Check for unnecessary object copying
  - Review if objects can be mutated instead of creating new ones
  - Verify array/object operations don't create unnecessary copies
  - Check for string concatenation that could use more efficient methods
- [ ] Review async operation memory
  - Check if promises hold references to large data unnecessarily
  - Review async/await patterns for memory efficiency
  - Verify callbacks don't retain unnecessary context
  - Check for promise chains that accumulate memory

### Documentation and Guidelines

- [ ] Document memory usage patterns
  - Document expected memory usage for each service
  - Document memory cleanup responsibilities
  - Create guidelines for memory-efficient coding patterns
  - Document memory monitoring procedures
- [ ] Document memory optimization strategies
  - Document when to use object pooling
  - Document when to use weak references
  - Document memory-efficient patterns for common operations
  - Create guidelines for avoiding memory leaks

## Notes

- This task is part of Phase 3: Holistic Review and Best Practices
- Section: 5. Performance Review
- Focus on identifying issues and improvements
- Document findings and decisions

- Task can be completed independently by a single agent

**TypeScript/Node.js Specific Libraries to Review:**

- **Axios** (`axios`): HTTP client for CursorRunnerService, TelegramService, ElevenLabs services. Should use shared instance with connection pooling.
- **ioredis** (`ioredis`): Redis client for CallbackService and BullMQ. Should use shared connection pool.
- **BullMQ** (`bullmq`): Job queue system. Review worker lifecycle, job data retention, and connection management.
- **Express** (`express`): Web framework. Review middleware memory patterns and request/response object lifecycle.
- **@elevenlabs/elevenlabs-js** (`@elevenlabs/elevenlabs-js`): ElevenLabs SDK. Review file handling and stream management for audio transcription/TTS.

## Related Tasks

- Previous: PHASE3-031
- Next: PHASE3-033

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
