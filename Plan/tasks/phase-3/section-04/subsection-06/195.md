# PHASE3-027: Refactor code organization issues

**Section**: 4. Code Organization
**Subsection**: 4.6
**Task ID**: PHASE3-027

## Description

Review and refactor code organization issues in the codebase to ensure best practices and alignment with the architecture documentation (`docs/architecture.md`). This task focuses on identifying and fixing misplaced files, reorganizing modules, extracting duplicate code, creating shared utilities, fixing naming inconsistencies, and improving module boundaries.

## Checklist

### File Placement Review

- [ ] Verify all source files are in appropriate directories according to `docs/architecture.md`
  - [ ] Controllers in `src/controllers/`
  - [ ] Services in `src/services/`
  - [ ] Models in `src/models/`
  - [ ] Routes in `src/routes/`
  - [ ] Middleware in `src/middleware/`
  - [ ] Utilities in `src/utils/`
  - [ ] Types in `src/types/`
  - [ ] Configuration in `src/config/`
  - [ ] Jobs in `src/jobs/` (created per PHASE3-022 - verify exists)
  - [ ] Errors in `src/errors/` (created per PHASE3-022 - verify exists)
  - [ ] Validators in `src/validators/` (created per PHASE3-022 - verify exists)
- [ ] Check for files in wrong locations (e.g., business logic in controllers, routes in services)
- [ ] Verify no source files are in root directory (except `src/index.ts`)
- [ ] Check that configuration files are in root (jest.config.ts, playwright.config.ts, tsconfig.json, etc.)
- [ ] Verify test files follow the structure: `tests/unit/`, `tests/integration/`, `tests/e2e/`, `tests/helpers/`, `tests/mocks/`, `tests/fixtures/`

### Module Organization

- [ ] Review module boundaries and ensure proper separation of concerns
  - [ ] Routes should only define endpoints and call controllers
  - [ ] Controllers should be thin and delegate to services
  - [ ] Services should contain business logic and be framework-agnostic
  - [ ] Models should only handle data structures and validation
  - [ ] Middleware should handle cross-cutting concerns
- [ ] Check for circular dependencies between modules
- [ ] Verify modules follow single responsibility principle
- [ ] Ensure proper use of barrel exports (index.ts) where appropriate
- [ ] Review import/export patterns for consistency

### Duplicate Code Identification

- [ ] Scan all TypeScript files in `src/` for duplicate code patterns
- [ ] Review test files for duplicate test utilities or patterns
  - [ ] **SPECIFIC FROM PHASE3-026**: Review mock reset functions in `tests/mocks/` - `resetTelegramApiMocks()`, `resetCursorRunnerApiMocks()`, and `resetRedisMocks()` all follow identical patterns and should be abstracted
  - [ ] **SPECIFIC FROM PHASE3-026**: Review fixture creation patterns - `createTelegramMessage()` and `createCursorRunnerResponse()` follow similar override patterns that could be abstracted
- [ ] Check for repeated error handling patterns that could be unified
- [ ] Identify duplicate validation logic that could be extracted
- [ ] Look for repeated API call patterns that could be abstracted
- [ ] Check for duplicate type definitions that could be shared
- [ ] Review repeated string literals that should be constants
- [ ] Identify repeated magic numbers that should be named constants

### Shared Utilities

- [ ] Review existing utilities in `src/utils/` (when files exist)
- [ ] Check if test utilities in `tests/helpers/` could be moved to `src/utils/` for production use
  - [ ] Review `tests/helpers/testUtils.ts` - identify utilities that could be shared (waitFor, createMockFn, randomString, randomEmail, randomInt, expectRejection)
  - [ ] **SPECIFIC FROM PHASE3-026**: Review `tests/helpers/apiHelpers.ts` - check if `HTTP_STATUS` constants should be moved to `src/utils/` for production use
  - [ ] **SPECIFIC FROM PHASE3-026**: Create generic `resetMockObject()` utility function to replace duplicate mock reset functions in `tests/mocks/`
  - [ ] **SPECIFIC FROM PHASE3-026**: Consider creating generic `createFixture()` utility to replace duplicate fixture creation patterns
- [ ] Create shared utilities for common patterns:
  - [ ] Error handling utilities
  - [ ] Validation utilities
  - [ ] HTTP client utilities
  - [ ] Date/time utilities
  - [ ] String manipulation utilities
- [ ] Ensure utilities are properly exported and documented
- [ ] Verify utilities follow DRY principles

### Naming Conventions

- [ ] Verify file naming follows consistent pattern (kebab-case or camelCase)
- [ ] Check that class names use PascalCase
- [ ] Verify function/variable names use camelCase
- [ ] Check that constants use UPPER_SNAKE_CASE or PascalCase
- [ ] Ensure interface names use PascalCase and start with 'I' or descriptive names
- [ ] Verify type aliases use PascalCase
- [ ] Check that test files follow naming pattern: `*.test.ts` or `*.spec.ts`
- [ ] Review naming consistency across similar modules

### Module Boundaries

- [ ] Verify services don't depend on Express or other framework-specific code
- [ ] Check that controllers don't contain business logic
- [ ] Ensure models don't contain business logic
- [ ] Verify routes don't contain business logic
- [ ] Check that middleware is reusable and composable
- [ ] Review dependency direction (dependencies should flow inward: routes → controllers → services → models)
- [ ] Ensure proper use of dependency injection pattern

### Code Structure Improvements

- [ ] Create `.gitkeep` files in empty directories to preserve structure
- [ ] Review and consolidate related files into appropriate modules
- [ ] Identify opportunities to create shared base classes or interfaces
- [ ] Check for opportunities to create shared middleware
- [ ] Review if any directories should be created or removed
- [ ] Verify alignment with Node.js/TypeScript best practices
- [ ] Ensure consistency with Express.js conventions

### Documentation and Verification

- [ ] Document any structural changes made
- [ ] Update `docs/architecture.md` if structure changes are made
- [ ] Document any deviations from standard patterns and rationale
- [ ] Verify all changes maintain test compatibility
- [ ] Run linting and type checking to ensure no issues introduced
- [ ] Verify improvements don't break existing functionality

## Notes

- This task is part of Phase 3: Holistic Review and Best Practices
- Section: 4. Code Organization
- Focus on identifying issues and improvements based on `docs/architecture.md`
- Document findings and decisions
- Current codebase state:
  - `src/` directory structure exists but is mostly empty (only `src/index.ts` exists, all other directories are empty with `.gitkeep` files)
  - Test utilities exist in `tests/helpers/`:
    - `testUtils.ts` - General test utilities (waitFor, createMockFn, randomString, randomEmail, randomInt, expectRejection)
    - `apiHelpers.ts` - API test helpers (createTestRequest, HTTP_STATUS constants, header helpers)
  - Test mocks exist in `tests/mocks/`:
    - `telegramApi.ts` - Mock Telegram API with resetTelegramApiMocks()
    - `cursorRunnerApi.ts` - Mock Cursor Runner API with resetCursorRunnerApiMocks()
    - `redis.ts` - Mock Redis client with resetRedisMocks()
  - Test fixtures exist in `tests/fixtures/`:
    - `telegramMessages.ts` - Telegram message fixtures with createTelegramMessage()
    - `apiResponses.ts` - API response fixtures with createCursorRunnerResponse()
- Reference findings from previous tasks:
  - PHASE3-022: ✅ **COMPLETED** - Created missing directories (`src/jobs/`, `src/errors/`, `src/validators/`) - verify they still exist
  - PHASE3-023: Review naming conventions consistency
  - PHASE3-024: Review module boundaries
  - PHASE3-025: Review import/export patterns
  - PHASE3-026: **SPECIFIC FINDINGS TO ADDRESS**:
    - Mock reset functions (`resetTelegramApiMocks()`, `resetCursorRunnerApiMocks()`, `resetRedisMocks()`) follow identical patterns - should be abstracted
    - Fixture creation patterns (`createTelegramMessage()`, `createCursorRunnerResponse()`) follow similar override patterns - should be abstracted
    - `HTTP_STATUS` constants in `apiHelpers.ts` should be reviewed for potential move to `src/utils/`
- When reviewing, consider both existing code and patterns that should be established for future code
- Pay special attention to test utilities - ensure they follow DRY principles and are reusable
- Consider creating shared utilities early to establish patterns for future development
- **This task consolidates findings from PHASE3-022 through PHASE3-026** - focus on implementing the specific improvements identified in those tasks, especially from PHASE3-026
- Since `src/` is mostly empty, most work will involve:
  1. Reviewing and refactoring test code organization
  2. Creating shared utilities based on test code patterns
  3. Establishing patterns for future production code
  4. Verifying directory structure matches architecture documentation

- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE3-026
- Next: PHASE3-028

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
