# PHASE3-027: Refactor code organization issues

**Section**: 4. Code Organization
**Subsection**: 4.6
**Task ID**: PHASE3-027

## Description

Review and refactor code organization issues in the codebase to ensure best practices and alignment with the architecture documentation (`docs/architecture.md`). This task focuses on identifying and fixing misplaced files, reorganizing modules, extracting duplicate code, creating shared utilities, fixing naming inconsistencies, and improving module boundaries.

## Checklist

### File Placement Review

- [ ] Verify all source files are in appropriate directories according to `docs/architecture.md`
  - [ ] Controllers in `src/controllers/`
  - [ ] Services in `src/services/`
  - [ ] Models in `src/models/`
  - [ ] Routes in `src/routes/`
  - [ ] Middleware in `src/middleware/`
  - [ ] Utilities in `src/utils/`
  - [ ] Types in `src/types/`
  - [ ] Configuration in `src/config/`
  - [ ] Jobs in `src/jobs/` (created per PHASE3-022 - verify exists)
  - [ ] Errors in `src/errors/` (created per PHASE3-022 - verify exists)
  - [ ] Validators in `src/validators/` (created per PHASE3-022 - verify exists)
- [ ] Check for files in wrong locations (e.g., business logic in controllers, routes in services)
- [ ] Verify no source files are in root directory (except `src/index.ts`)
- [ ] Check that configuration files are in root (jest.config.ts, playwright.config.ts, tsconfig.json, etc.)
- [ ] Verify test files follow the structure: `tests/unit/`, `tests/integration/`, `tests/e2e/`, `tests/helpers/`, `tests/mocks/`, `tests/fixtures/`

### Module Organization

- [ ] Review module boundaries and ensure proper separation of concerns
  - [ ] Routes should only define endpoints and call controllers
  - [ ] Controllers should be thin and delegate to services
  - [ ] Services should contain business logic and be framework-agnostic
  - [ ] Models should only handle data structures and validation
  - [ ] Middleware should handle cross-cutting concerns
- [ ] Check for circular dependencies between modules
- [ ] Verify modules follow single responsibility principle
- [ ] Ensure proper use of barrel exports (index.ts) where appropriate
- [ ] Review import/export patterns for consistency

### Duplicate Code Identification

- [ ] Scan all TypeScript files in `src/` for duplicate code patterns
- [ ] Review test files for duplicate test utilities or patterns
  - [ ] **SPECIFIC FROM PHASE3-026**: Review mock reset functions in `tests/mocks/` - `resetTelegramApiMocks()`, `resetCursorRunnerApiMocks()`, and `resetRedisMocks()` all follow identical patterns and should be abstracted
  - [ ] **SPECIFIC FROM PHASE3-026**: Review fixture creation patterns - `createTelegramMessage()` and `createCursorRunnerResponse()` follow similar override patterns that could be abstracted
- [ ] Check for repeated error handling patterns that could be unified
- [ ] Identify duplicate validation logic that could be extracted
- [ ] Look for repeated API call patterns that could be abstracted
- [ ] Check for duplicate type definitions that could be shared
- [ ] Review repeated string literals that should be constants
- [ ] Identify repeated magic numbers that should be named constants

### Shared Utilities

- [ ] Review existing utilities in `src/utils/` (when files exist)
- [ ] Check if test utilities in `tests/helpers/` could be moved to `src/utils/` for production use
  - [ ] Review `tests/helpers/testUtils.ts` - identify utilities that could be shared (waitFor, createMockFn, randomString, randomEmail, randomInt, expectRejection)
  - [ ] **SPECIFIC FROM PHASE3-026**: Review `tests/helpers/apiHelpers.ts` - check if `HTTP_STATUS` constants should be moved to `src/utils/` for production use
  - [ ] **SPECIFIC FROM PHASE3-026**: Create generic `resetMockObject()` utility function to replace duplicate mock reset functions in `tests/mocks/`
  - [ ] **SPECIFIC FROM PHASE3-026**: Consider creating generic `createFixture()` utility to replace duplicate fixture creation patterns
- [ ] Create shared utilities for common patterns:
  - [ ] Error handling utilities
  - [ ] Validation utilities
  - [ ] HTTP client utilities
  - [ ] Date/time utilities
  - [ ] String manipulation utilities
- [ ] Ensure utilities are properly exported and documented
- [ ] Verify utilities follow DRY principles

### Naming Conventions

- [ ] Verify file naming follows consistent pattern (kebab-case or camelCase)
- [ ] Check that class names use PascalCase
- [ ] Verify function/variable names use camelCase
- [ ] Check that constants use UPPER_SNAKE_CASE or PascalCase
- [ ] Ensure interface names use PascalCase and start with 'I' or descriptive names
- [ ] Verify type aliases use PascalCase
- [ ] Check that test files follow naming pattern: `*.test.ts` or `*.spec.ts`
- [ ] Review naming consistency across similar modules

### Module Boundaries

- [ ] Verify services don't depend on Express or other framework-specific code
- [ ] Check that controllers don't contain business logic
- [ ] Ensure models don't contain business logic
- [ ] Verify routes don't contain business logic
- [ ] Check that middleware is reusable and composable
- [ ] Review dependency direction (dependencies should flow inward: routes → controllers → services → models)
- [ ] Ensure proper use of dependency injection pattern

### Code Structure Improvements

- [ ] Create `.gitkeep` files in empty directories to preserve structure
- [ ] Review and consolidate related files into appropriate modules
- [ ] Identify opportunities to create shared base classes or interfaces
- [ ] Check for opportunities to create shared middleware
- [ ] Review if any directories should be created or removed
- [ ] Verify alignment with Node.js/TypeScript best practices
- [ ] Ensure consistency with Express.js conventions

### Documentation and Verification

- [ ] Document any structural changes made
- [ ] Update `docs/architecture.md` if structure changes are made
- [ ] Document any deviations from standard patterns and rationale
- [ ] Verify all changes maintain test compatibility
- [ ] Run linting and type checking to ensure no issues introduced
- [ ] Verify improvements don't break existing functionality

## Notes

- This task is part of Phase 3: Holistic Review and Best Practices
- Section: 4. Code Organization
- Focus on identifying issues and improvements based on `docs/architecture.md`
- Document findings and decisions
- Current codebase state:
  - `src/` directory structure exists but is mostly empty (only `src/index.ts` exists, all other directories are empty with `.gitkeep` files)
  - Test utilities exist in `tests/helpers/`:
    - `testUtils.ts` - General test utilities (waitFor, createMockFn, randomString, randomEmail, randomInt, expectRejection)
    - `apiHelpers.ts` - API test helpers (createTestRequest, HTTP_STATUS constants, header helpers)
  - Test mocks exist in `tests/mocks/`:
    - `telegramApi.ts` - Mock Telegram API with resetTelegramApiMocks()
    - `cursorRunnerApi.ts` - Mock Cursor Runner API with resetCursorRunnerApiMocks()
    - `redis.ts` - Mock Redis client with resetRedisMocks()
  - Test fixtures exist in `tests/fixtures/`:
    - `telegramMessages.ts` - Telegram message fixtures with createTelegramMessage()
    - `apiResponses.ts` - API response fixtures with createCursorRunnerResponse()
- Reference findings from previous tasks:
  - PHASE3-022: ✅ **COMPLETED** - Created missing directories (`src/jobs/`, `src/errors/`, `src/validators/`) - verify they still exist
  - PHASE3-023: Review naming conventions consistency
  - PHASE3-024: Review module boundaries
  - PHASE3-025: Review import/export patterns
  - PHASE3-026: **SPECIFIC FINDINGS TO ADDRESS**:
    - Mock reset functions (`resetTelegramApiMocks()`, `resetCursorRunnerApiMocks()`, `resetRedisMocks()`) follow identical patterns - should be abstracted
    - Fixture creation patterns (`createTelegramMessage()`, `createCursorRunnerResponse()`) follow similar override patterns - should be abstracted
    - `HTTP_STATUS` constants in `apiHelpers.ts` should be reviewed for potential move to `src/utils/`
- When reviewing, consider both existing code and patterns that should be established for future code
- Pay special attention to test utilities - ensure they follow DRY principles and are reusable
- Consider creating shared utilities early to establish patterns for future development
- **This task consolidates findings from PHASE3-022 through PHASE3-026** - focus on implementing the specific improvements identified in those tasks, especially from PHASE3-026
- Since `src/` is mostly empty, most work will involve:
  1. Reviewing and refactoring test code organization
  2. Creating shared utilities based on test code patterns
  3. Establishing patterns for future production code
  4. Verifying directory structure matches architecture documentation

- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE3-026
- Next: PHASE3-028

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

