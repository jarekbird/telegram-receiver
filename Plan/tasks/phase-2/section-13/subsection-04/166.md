# PHASE2-103: Write integration tests for webhook flow

**Section**: 13. Testing
**Subsection**: 13.4
**Task ID**: PHASE2-103

## Description

Write integration tests for the Telegram webhook flow. These tests should verify the complete end-to-end flow from webhook reception through job processing. While Rails has controller specs (`telegram_controller_spec.rb`) and job specs (`telegram_message_job_spec.rb`) as unit tests, this task creates integration tests that test multiple components working together.

**Rails Reference Files:**

- `jarek-va/app/controllers/telegram_controller.rb` - Webhook endpoint implementation
- `jarek-va/app/jobs/telegram_message_job.rb` - Message processing job
- `jarek-va/spec/controllers/telegram_controller_spec.rb` - Controller unit tests (reference for behavior)
- `jarek-va/spec/jobs/telegram_message_job_spec.rb` - Job unit tests (reference for behavior)

## Checklist

- [ ] Create `tests/integration/api/telegram-webhook.test.ts` using Supertest
- [ ] Test webhook reception with authentication (X-Telegram-Bot-Api-Secret-Token header)
- [ ] Test webhook reception without authentication (should return 401 when secret is configured)
- [ ] Test webhook reception when secret is not configured (should accept request)
- [ ] Test async handler execution for message updates
- [ ] Test async handler execution for edited_message updates
- [ ] Test async handler execution for callback_query updates
- [ ] Test async handler execution for unhandled update types
- [ ] Test end-to-end flow: webhook → async handler execution → external service calls
- [ ] Test message processing with command messages (/start, /help, /status)
- [ ] Test message processing with non-command messages (forwarded to cursor-runner)
- [ ] Test error handling when async handler execution fails (should return 200 to avoid Telegram retries)
- [ ] Test error handling when handler processing fails (should send error message to user)
- [ ] Mock TelegramService (send_message, download_file, send_voice, bot.api.answer_callback_query, etc.)
- [ ] Mock CursorRunnerService (iterate method)
- [ ] Mock CursorRunnerCallbackService (store_pending_request, remove_pending_request)
- [ ] Mock Redis for callback state management
- [ ] Mock SystemSetting (enabled?, disabled? methods)
- [ ] Mock ElevenLabs services (speech-to-text, text-to-speech)
- [ ] Mock async handler execution to verify handler is called correctly
- [ ] Verify handler receives correct update data (TelegramUpdate object)
- [ ] Test that webhook returns 200 OK immediately (before handler processing completes)
- [ ] Use fixtures from `tests/fixtures/telegramMessages.ts` for test data
- [ ] Test with different message types (text, audio/voice, callback queries)
- [ ] Test callback query answer behavior (job should answer callback query before processing)
- [ ] Test callback query answer error handling (should handle gracefully if answer fails)
- [ ] Test CURSOR_DEBUG acknowledgment messages (should send acknowledgment when debug enabled)
- [ ] Test audio response behavior (should respond with audio if original message was audio and audio output not disabled)
- [ ] Test SystemSetting checks (debug flag, allow_audio_output flag)
- [ ] Test audio transcription flow (download, transcribe, cleanup)
- [ ] Test text-to-speech response flow (synthesize, send voice, cleanup, fallback to text on error)
- [ ] Verify proper cleanup and isolation between tests

## Test Scenarios

### Authentication Tests

1. **Without authentication when secret is configured**: Should return 401 Unauthorized
2. **Without authentication when secret is not configured**: Should accept request (return 200)
3. **With valid authentication**: Should accept request and process

### Update Type Tests

1. **Message update**: Should execute async handler and process message
2. **Edited message update**: Should execute async handler and process edited message
3. **Callback query update**: Should execute async handler and process callback
4. **Unhandled update type**: Should execute async handler but handle gracefully

### Message Processing Tests

1. **Command messages** (/start, /help, /status): Should process locally and send response
2. **Non-command messages**: Should forward to cursor-runner via CursorRunnerService
3. **Audio/voice messages**: Should transcribe and process (if implemented)
   - Download audio file from Telegram
   - Transcribe using ElevenLabs service
   - Replace message text with transcribed text
   - Continue processing with transcribed text
   - Clean up downloaded audio file
   - Handle transcription errors gracefully
4. **Audio response**: When original message was audio, should respond with audio (if audio output not disabled)
   - Convert response text to speech using ElevenLabs
   - Send as voice message
   - Fallback to text message if audio generation fails
   - Clean up generated audio file
5. **Callback query processing**: Should answer callback query before processing
   - Answer callback query with "Processing..." text
   - Handle answer errors gracefully (log but continue)
   - Process callback data by forwarding to cursor-runner
6. **CURSOR_DEBUG acknowledgment**: Should send acknowledgment message when debug enabled
   - Check SystemSetting for 'debug' flag
   - Send "⏳ Processing your request..." message if enabled
   - Skip acknowledgment if debug disabled

### Error Handling Tests

1. **Async handler execution error**: Should return 200 OK, log error, send error message to user if chat_id available
2. **Handler processing error**: Should log error, send error message to user, handle error gracefully
3. **Missing chat_id in error**: Should not attempt to send error message
4. **Callback query answer error**: Should log error but continue processing callback
5. **Audio transcription error**: Should send error message to user and return early
6. **Audio generation error**: Should fallback to text message if text-to-speech fails
7. **Error sending error message**: Should log error but not crash (nested error handling)

### Integration Flow Tests

1. **Complete flow**: HTTP POST → Controller → Async Handler Execution → External Services
2. **Verify handler data**: Ensure update data is correctly passed to handler as TelegramUpdate object
3. **Verify immediate response**: Webhook should return 200 OK before handler processing completes

## Implementation Notes

- Use Supertest for HTTP endpoint testing
- Use Jest for test framework
- Mock external services (TelegramService, CursorRunnerService) using Jest mocks
- Mock async handler execution to verify handler is called without actually processing
- Mock Redis for callback state management
- Mock SystemSetting to control debug and audio output flags
- Mock ElevenLabs services for audio transcription and text-to-speech
- Use test fixtures from `tests/fixtures/telegramMessages.ts`
- Ensure proper test isolation (cleanup between tests, reset mocks between tests)
- Reference Rails specs for expected behavior and edge cases
- Test should verify the complete flow but mock external dependencies
- Note: The controller passes update as TelegramUpdate object to handler (not JSON string)
- Note: The controller excludes `:controller`, `:action`, `:format`, `:telegram` from params before passing to handler

## Notes

- This task is part of Phase 2: File-by-File Conversion
- Section: 13. Testing
- Subsection: 13.4 Integration Tests
- Rails has unit tests (controller specs, job specs) but no integration tests - this task creates new integration tests based on the Rails unit test behavior
- Integration tests should test multiple components together (controller + async handler execution)
- External services should be mocked to ensure test isolation and speed
- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE2-102
- Next: PHASE2-104

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

