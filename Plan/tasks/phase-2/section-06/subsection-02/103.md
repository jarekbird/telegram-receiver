# PHASE2-040: Implement store_pending_request method

**Section**: 6. CursorRunnerCallbackService Conversion
**Subsection**: 6.2
**Task ID**: PHASE2-040

## Description

Implement the `storePendingRequest` method in the CursorRunnerCallbackService class. This method stores pending cursor-runner request information in Redis with TTL support. It takes a unique request ID, data object, and optional TTL, then stores the serialized JSON data in Redis with automatic expiration.

Reference the Rails implementation at `jarek-va/app/services/cursor_runner_callback_service.rb` (lines 24-32) for complete behavior details.

## Checklist

- [ ] Implement `storePendingRequest(requestId: string, data: object, ttl?: number)` method
  - Method signature: `requestId` (required string), `data` (required object), `ttl` (optional number, defaults to `DEFAULT_TTL` constant which is 3600 seconds / 1 hour)
  - Return type: `void` (method doesn't return a value)
- [ ] Use private `redisKey(requestId: string)` helper method to generate Redis key with prefix
  - The helper method prepends `REDIS_KEY_PREFIX` constant (`'cursor_runner_callback:'`) to the request ID
- [ ] Serialize data object to JSON string using `JSON.stringify(data)`
- [ ] Store serialized JSON in Redis using `redis.setex(key, ttl, jsonString)` method
  - **IMPORTANT**: Use `ioredis` package (project standard from PHASE2-039)
  - The `ioredis` package supports `setex(key, ttl, value)` method which matches the Rails API exactly
  - Use the generated Redis key from `redisKey()` helper
  - Use provided `ttl` parameter or default to `DEFAULT_TTL` (3600 seconds)
  - Store the JSON stringified data
  - Note: `ioredis` also supports `set(key, value, 'EX', ttl)` as an alternative, but `setex()` is preferred for consistency with Rails implementation
- [ ] Add error handling for Redis operations
  - Wrap Redis operations in try/catch block
  - Handle Redis connection errors (catch Redis client exceptions)
  - Note: `JSON.stringify()` typically doesn't throw errors for plain objects, but Redis operations can fail
  - Log errors with `console.error()` including request ID and error message
  - Re-throw or handle errors appropriately (consider whether to throw or log silently - Rails version doesn't handle errors explicitly)
- [ ] Log successful operation with info level using `console.log()`
  - Log message should include: request ID and TTL value
  - Format: `"Stored pending cursor-runner request: {requestId}, TTL: {ttl}s"`
  - Use `console.log()` for info messages (matching PHASE2-039 convention, as no logger utility exists yet in the project)

## Notes

- This task is part of Phase 2: File-by-File Conversion
- Section: 6. CursorRunnerCallbackService Conversion
- Subsection: 6.2
- Reference the Rails implementation at `jarek-va/app/services/cursor_runner_callback_service.rb` (lines 24-32) for complete behavior details

**Rails Implementation Details:**

- Method signature: `store_pending_request(request_id, data, ttl: DEFAULT_TTL)`
- Uses `redis_key(request_id)` private helper to generate key with `REDIS_KEY_PREFIX` prefix
- Serializes data with `data.to_json`
- Uses `@redis.setex(key, ttl, data.to_json)` to store with TTL
- Logs: `Rails.logger.info("Stored pending cursor-runner request: #{request_id}, TTL: #{ttl}s")`
- No explicit error handling in Rails version (relies on Redis client exceptions)

**TypeScript Implementation Requirements:**

- Method name: `storePendingRequest` (camelCase conversion from Ruby snake_case)
- Parameters: `requestId: string`, `data: object`, `ttl?: number` (optional, defaults to `DEFAULT_TTL`)
- Use the private `redisKey()` helper method that should already exist from PHASE2-039
- Use `JSON.stringify()` for serialization (TypeScript/Node.js equivalent of Ruby's `to_json`)
- Use Redis client's `setex()` method from `ioredis` package (project standard from PHASE2-039)
  - `ioredis` supports `setex(key, ttl, value)` which matches the Rails API exactly
  - Note: `ioredis` also supports `set(key, value, 'EX', ttl)` as an alternative, but `setex()` is preferred for consistency with Rails implementation
- Add proper error handling (try/catch) for Redis operations and log errors
  - Wrap Redis `setex()` call in try/catch block
  - Catch Redis client exceptions (connection errors, etc.)
  - Log errors with `console.error()` including request ID and error details
  - Consider whether to re-throw errors or handle gracefully (Rails version doesn't handle errors explicitly)
- Use `console.log()` for info messages (matching PHASE2-039 convention, as no logger utility exists yet in the project)
- Ensure method is added to the `CursorRunnerCallbackService` class created in PHASE2-039

**Dependencies:**

- Assumes `CursorRunnerCallbackService` class structure exists (from PHASE2-039)
- Assumes `REDIS_KEY_PREFIX` and `DEFAULT_TTL` constants exist
- Assumes private `redisKey()` helper method exists
- Assumes Redis client instance is available as private property

- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE2-039
- Next: PHASE2-041

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

