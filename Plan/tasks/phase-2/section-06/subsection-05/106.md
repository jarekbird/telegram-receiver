# PHASE2-043: Add error handling and TTL management

**Section**: 6. CursorRunnerCallbackService Conversion
**Subsection**: 6.5
**Task ID**: PHASE2-043

## Description

Add comprehensive error handling and TTL validation to all methods in the CursorRunnerCallbackService class. This task enhances the service with robust error handling for Redis operations and validates TTL values to ensure data integrity.

Reference the Rails implementation at `jarek-va/app/services/cursor_runner_callback_service.rb` for complete behavior details.

## Checklist

- [ ] Add error handling to `storePendingRequest` method
  - Wrap Redis `setex()` operation in try/catch block
  - Handle Redis connection errors (e.g., ECONNREFUSED, timeout errors)
  - Handle Redis operation errors (e.g., write failures, memory errors)
  - Log errors with appropriate level (error level) including request ID and error details
  - Consider whether to throw errors or handle gracefully (recommend throwing for critical operations)
  - Ensure error messages are descriptive and include context (request ID, TTL value)
- [ ] Add error handling to `getPendingRequest` method
  - The Rails implementation handles JSON parsing errors (lines 43-48), and this was already implemented in PHASE2-041 - ensure this is preserved
  - Add Redis connection error handling (wrap `get()` operation in try/catch)
  - Add Redis operation error handling
  - Log Redis errors with error level, including request ID
  - JSON parsing errors should return null (as per Rails implementation and PHASE2-041)
  - Redis errors should also return null (to match graceful degradation pattern)
- [ ] Add error handling to `removePendingRequest` method
  - Wrap Redis `del()` operation in try/catch block
  - Handle Redis connection errors
  - Handle Redis operation errors
  - Log errors with appropriate level (error level) including request ID
  - Consider whether to throw errors or handle gracefully (recommend logging and continuing, as removal is cleanup operation)
- [ ] Add TTL validation to `storePendingRequest` method
  - Validate that TTL is a positive integer (greater than 0)
  - Validate that TTL is within reasonable bounds (e.g., between 1 and 86400 seconds = 24 hours)
  - Throw error or use default TTL if validation fails (recommend throwing error for invalid values)
  - Log warning if invalid TTL is provided and default is used (if choosing graceful handling)
  - Ensure TTL parameter is properly typed in TypeScript (number, optional)
- [ ] Ensure consistent error logging across all methods
  - Use consistent error log format across all methods
  - Include relevant context in error logs (request ID, operation type, error message)
  - Use appropriate log levels (error for errors, warn for warnings, info for successful operations)
  - Check project's logging setup and use the same logger consistently

## Notes

- This task is part of Phase 2: File-by-File Conversion
- Section: 6. CursorRunnerCallbackService Conversion
- Subsection: 6.5
- Reference the Rails implementation at `jarek-va/app/services/cursor_runner_callback_service.rb` for complete behavior details

**Rails Implementation Analysis:**

**Error Handling:**

- `get_pending_request` (lines 37-49): Has JSON parsing error handling - catches `JSON::ParserError`, logs error with request_id and error message, returns nil
- `store_pending_request` (lines 28-32): No explicit error handling - relies on Redis client exceptions
- `remove_pending_request` (lines 53-57): No explicit error handling - relies on Redis client exceptions
- No Redis connection error handling in any method

**TTL Management:**

- `DEFAULT_TTL` constant defined as `3600` (1 hour) - line 10
- `store_pending_request` accepts optional `ttl` parameter with default value `DEFAULT_TTL` - line 28
- No TTL validation - accepts any integer value (could be negative, zero, or extremely large)

**Logging:**

- `store_pending_request`: Logs info message with request_id and TTL - line 31
- `get_pending_request`: Logs error message for JSON parsing failures - lines 44-47
- `remove_pending_request`: Logs info message with request_id - line 56
- No logging for successful `get_pending_request` operations

**TypeScript Implementation Requirements:**

**Error Handling Strategy:**

- Add comprehensive try/catch blocks around all Redis operations
- Handle Redis connection errors (network failures, connection refused, timeouts)
- Handle Redis operation errors (write failures, memory errors, command errors)
- For `getPendingRequest`: Return null on any error (matching Rails graceful degradation)
- For `storePendingRequest`: Consider throwing errors (critical operation) or logging and returning false
- For `removePendingRequest`: Log errors but don't throw (cleanup operation, non-critical)

**TTL Validation:**

- Validate TTL is a positive integer (> 0)
- Validate TTL is within reasonable bounds (recommend 1-86400 seconds = 1 second to 24 hours)
- Throw TypeError or RangeError for invalid TTL values
- Ensure TypeScript type checking (number type, optional parameter)

**Logging:**

- Use consistent error logging format: `{ operation: 'storePendingRequest', requestId: '...', error: '...' }`
- Include request ID in all error logs for traceability
- Use appropriate log levels (error for errors, warn for warnings, info for info)
- Check project's logging setup (may use console.log, winston, pino, or another logger)
- Note: Based on PHASE2-039, PHASE2-040, PHASE2-041, and PHASE2-042, the project currently uses `console.log()` for info messages and `console.error()` for error messages (no logger utility exists yet)

**Dependencies:**

- Assumes `CursorRunnerCallbackService` class structure exists (from PHASE2-039)
- Assumes all methods exist (from PHASE2-039, PHASE2-040, PHASE2-041, PHASE2-042)
- Assumes Redis client instance is available as private property
- Assumes logging system is available

- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE2-042
- Next: PHASE2-044

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
