# PHASE2-087: Register job processor with queue

**Section**: 10. TelegramMessageJob Conversion
**Subsection**: 10.11
**Task ID**: PHASE2-087

## Description

Set up BullMQ queue system and register TelegramMessageJob processor to handle background job processing in TypeScript/Node.js. This task converts the Sidekiq job queue infrastructure from Rails to BullMQ in Node.js.

The Rails implementation uses:

- **Sidekiq** as the ActiveJob adapter (configured in `jarek-va/config/application.rb` line 31)
- **Sidekiq initializer** (`jarek-va/config/initializers/sidekiq.rb`) for Redis connection and configuration
- **Sidekiq YAML config** (`jarek-va/config/sidekiq.yml`) for queue and concurrency settings
- **Sidekiq worker process** started separately (`bundle exec sidekiq` or Docker service)
- **TelegramMessageJob** uses `queue_as :default` (line 11 in `jarek-va/app/jobs/telegram_message_job.rb`)

The TypeScript/Node.js implementation should use:

- **BullMQ** (already in package.json dependencies) as the job queue system
- **Redis connection** (already configured via `redis`/`ioredis` packages)
- **Queue worker** to process jobs from the queue
- **Queue configuration** matching Sidekiq settings (concurrency, retry, etc.)

## Checklist

### BullMQ Queue Configuration

- [ ] Create `src/config/queue.ts` or similar configuration file
  - [ ] Configure Redis connection using environment variable `REDIS_URL` (default: `redis://localhost:6379/0`)
  - [ ] Match Rails Sidekiq configuration: `jarek-va/config/initializers/sidekiq.rb` lines 7-28
  - [ ] Support Docker environment (Redis URL: `redis://redis:6379/0`) and local development
  - [ ] Configure default job options (retry: 3, backtrace: true) matching Rails lines 34-37
  - [ ] Reference Rails implementation: `jarek-va/config/initializers/sidekiq.rb`

### Queue Configuration File

- [ ] Create `src/config/queue-config.ts` or YAML equivalent
  - [ ] Define concurrency settings per environment:
    - Development: 2 (matching Rails `jarek-va/config/sidekiq.yml` line 21)
    - Production: 10 (matching Rails line 12)
    - Test: 1 (matching Rails line 27)
  - [ ] Define queue names: `['default']` for development/test, `['critical', 'default', 'high_priority', 'low_priority']` for production
  - [ ] Reference Rails implementation: `jarek-va/config/sidekiq.yml`

### Create Queue Worker

- [ ] Create `src/workers/telegram-message-worker.ts` or similar
  - [ ] Import BullMQ `Worker` class
  - [ ] Create worker instance for 'default' queue
  - [ ] Configure worker with concurrency from config file
  - [ ] Set up Redis connection from queue configuration
  - [ ] Reference BullMQ documentation for worker setup

### Register TelegramMessageJob Processor

- [ ] Register job processor in the worker
  - [ ] Import TelegramMessageJob class (created in previous tasks)
  - [ ] Register processor function that calls `TelegramMessageJob.process()` (Note: TypeScript uses `process()` method, equivalent to Rails `perform()` method)
  - [ ] Handle job data parsing (JSON string or object, matching Rails line 17-18)
  - [ ] Ensure processor matches Rails `perform` method signature: `process(update)` (TypeScript method name is `process`, Rails equivalent is `perform`)
  - [ ] Extract update from job data: `job.data.update` (job payload contains `{ update: TelegramUpdate }`)
  - [ ] Pass update to `TelegramMessageJob.process(update)` method
  - [ ] Reference Rails implementation: `jarek-va/app/jobs/telegram_message_job.rb` lines 10-51
  - [ ] Reference TypeScript implementation: PHASE2-078 for `process()` method signature

### Configure Queue Options

- [ ] Set up queue options matching Sidekiq behavior
  - [ ] Configure retry attempts: 3 (matching Rails `Sidekiq.default_job_options` line 35)
  - [ ] Enable backtrace logging: true (matching Rails line 36)
  - [ ] Configure job removal after completion (optional, for cleanup)
  - [ ] Set job timeout if needed
  - [ ] Reference Rails implementation: `jarek-va/config/initializers/sidekiq.rb` lines 34-37

### Add Error Handlers

- [ ] Add worker-level error handling
  - [ ] Handle worker errors (connection failures, etc.)
  - [ ] Log errors with appropriate log level
  - [ ] Handle job processing errors (already handled in TelegramMessageJob.perform, but ensure worker doesn't crash)
  - [ ] Add error event listeners for worker
  - [ ] Reference Rails Sidekiq error handling patterns

### Start Worker in Application Startup

- [ ] Integrate worker startup in application initialization
  - [ ] Create `src/workers/index.ts` or similar entry point
  - [ ] Start worker when application starts (in `src/index.ts` or main entry point)
  - [ ] Handle graceful shutdown (close worker on SIGTERM/SIGINT)
  - [ ] Ensure worker starts only in appropriate environments (not in test unless needed)
  - [ ] Match Rails behavior: Sidekiq runs as separate process, but for Node.js we can run in same process or separate
  - [ ] Consider Docker deployment: worker should start automatically with application

### Queue Creation for Job Enqueueing

- [ ] Ensure queue is created for enqueueing jobs
  - [ ] Create `src/queues/telegram-message-queue.ts` or similar
  - [ ] Export queue instance for use in controllers/services
  - [ ] Configure queue with same Redis connection as worker
  - [ ] Set queue name: 'default' (matching Rails `queue_as :default`)
  - [ ] This queue will be used by TelegramController to enqueue jobs (via `queue.add('telegram-message', { update })` equivalent to Rails `TelegramMessageJob.perform_later(update.to_json)`)
  - [ ] Job payload should match `TelegramMessageJobPayload` interface: `{ update: TelegramUpdate }`

### Logging Configuration

- [ ] Configure queue/worker logging
  - [ ] Set log level to INFO (matching Rails `Sidekiq.logger.level = Logger::INFO` line 31)
  - [ ] Ensure worker logs job processing events
  - [ ] Log queue connection status
  - [ ] Reference Rails implementation: `jarek-va/config/initializers/sidekiq.rb` line 31

## Notes

- This task is part of Phase 2: File-by-File Conversion
- Section: 10. TelegramMessageJob Conversion
- Reference the Rails implementation for behavior

### Rails Implementation Details

1. **Sidekiq Configuration** (`jarek-va/config/initializers/sidekiq.rb`):
   - Redis URL: `ENV.fetch('REDIS_URL', 'redis://localhost:6379/0')`
   - Default job options: `{ retry: 3, backtrace: true }`
   - Log level: `Logger::INFO`

2. **Sidekiq YAML Config** (`jarek-va/config/sidekiq.yml`):
   - Development: concurrency 2, queues: ['default']
   - Production: concurrency 10, queues: ['critical', 'default', 'high_priority', 'low_priority']
   - Test: concurrency 1, queues: ['default']

3. **TelegramMessageJob Queue** (`jarek-va/app/jobs/telegram_message_job.rb` line 11):
   - Uses `queue_as :default` to specify queue name

4. **Job Enqueueing** (`jarek-va/app/controllers/telegram_controller.rb` line 22):
   - Jobs are enqueued via `TelegramMessageJob.perform_later(update.to_json)`
   - In TypeScript: Use `queue.add('telegram-message', { update } as TelegramMessageJobPayload)` where `queue` is the BullMQ Queue instance

### TypeScript/Node.js Implementation Notes

1. **BullMQ Setup**:
   - Use `bullmq` package (already in dependencies)
   - Create `Queue` instance for enqueueing jobs
   - Create `Worker` instance for processing jobs
   - Both use same Redis connection

2. **Queue vs Worker**:
   - Queue: Used to add jobs (equivalent to `perform_later` in Rails)
     - Example: `queue.add('telegram-message', { update } as TelegramMessageJobPayload)`
   - Worker: Processes jobs from queue (equivalent to Sidekiq worker process)
     - Worker processor function receives `Job<TelegramMessageJobPayload>` and calls `TelegramMessageJob.process(job.data.update)`

3. **Environment Variables**:
   - Use `REDIS_URL` environment variable (same as Rails)
   - Default to `redis://localhost:6379/0` for local development
   - Use `redis://redis:6379/0` in Docker (matching Rails Docker setup)

4. **Worker Startup**:
   - Can run in same process as Express app or separate process
   - For Docker, consider running as separate service (like Rails Sidekiq) or same container
   - Ensure graceful shutdown on SIGTERM/SIGINT

### Dependencies

This task depends on:

- PHASE2-078: TelegramMessageJob `process` method implementation (TypeScript equivalent of Rails `perform` method)
- PHASE2-077: TelegramMessageJob class structure
- PHASE2-015: BaseJobProcessor class (if using base class pattern)
- PHASE2-006: TelegramMessageJobPayload type definition
- Redis connection setup (should already be configured)
- BullMQ package (already in package.json)

### Task Scope

- Task can be completed independently by a single agent
- Focus on setting up queue infrastructure and worker registration
- Ensure configuration matches Rails Sidekiq settings
- Worker should process jobs from 'default' queue

## Related Tasks

- Previous: PHASE2-086
- Next: PHASE2-088

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
