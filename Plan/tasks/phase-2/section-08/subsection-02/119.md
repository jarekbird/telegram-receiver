# PHASE2-056: Implement webhook endpoint handler

**Section**: 8. TelegramController Conversion
**Subsection**: 8.2
**Task ID**: PHASE2-056

## Description

Convert the webhook endpoint handler from Rails to TypeScript/Node.js. This endpoint receives Telegram updates via POST request, parses them, and enqueues them for asynchronous processing. The handler must return 200 OK immediately to Telegram to prevent retries, even if errors occur.

Reference the Rails implementation in `jarek-va/app/controllers/telegram_controller.rb` (lines 12-48) for the complete behavior.

## Checklist

- [ ] Implement `webhook` handler method with signature `webhook(req: Request, res: Response): Promise<void>`
- [ ] Parse request body as TelegramUpdate:
  - [ ] Check Content-Type header for `application/json`
  - [ ] If JSON, parse from request body directly
  - [ ] If form-encoded, parse from request body/form data
  - [ ] Handle both content types appropriately (similar to Rails `request.parameters` vs `params`)
- [ ] Remove framework-specific parameters from parsed update:
  - [ ] Remove `controller`, `action`, `format`, `telegram` parameters (if present)
  - [ ] Ensure only Telegram update data remains
- [ ] Log the received Telegram update for debugging (using logger with `update.inspect` equivalent)
- [ ] Execute async handler to process update asynchronously (call `TelegramMessageHandler` equivalent with TelegramUpdate object)
- [ ] Return 200 OK immediately after starting async handler execution (before handler processing completes)
- [ ] Implement comprehensive error handling:
  - [ ] Catch all errors (StandardError equivalent - catch all exceptions)
  - [ ] Log error message and stack trace (full backtrace)
  - [ ] Convert update to plain object/hash if needed (handle both Hash and object types)
  - [ ] Extract chat info from update using `extractChatInfoFromUpdate` helper method (if available)
  - [ ] If chat_id is available, attempt to send error message to user via TelegramService:
    - [ ] Use `parse_mode: 'HTML'` when sending error message
    - [ ] Include `reply_to_message_id` if message_id is available
    - [ ] Wrap error message sending in try-catch to handle send failures gracefully
    - [ ] Log any errors from sending error message (but don't re-raise)
  - [ ] Always return 200 OK even on error (to prevent Telegram from retrying)
- [ ] Reference `jarek-va/app/controllers/telegram_controller.rb` lines 12-48 for implementation details

## Notes

- This task is part of Phase 2: File-by-File Conversion
- Section: 8. TelegramController Conversion
- Reference the Rails implementation (`jarek-va/app/controllers/telegram_controller.rb` lines 12-48) for complete behavior
- **Important**: The webhook authentication is handled by middleware (implemented in PHASE2-057), so this method assumes authentication has already passed
- The Rails implementation:
  - Checks Content-Type: if `application/json`, uses `request.parameters`; otherwise uses `params` (handles form-encoded)
  - Removes Rails-specific params (`controller`, `action`, `format`, `telegram`) using `update.except(...)` before processing
  - Logs the received update using `Rails.logger.info("Received Telegram update: #{update.inspect}")`
  - Converts update to JSON string using `update.to_json` before passing to job
  - Always returns 200 OK to Telegram, even on errors, to prevent retries
  - Error handling:
    - Converts update to hash if needed: `update_hash = update.is_a?(Hash) ? update : update.to_h`
    - Extracts chat info using `extract_chat_info_from_update(update_hash)` private method
    - Sends error message with `parse_mode: 'HTML'` and `reply_to_message_id` if available
    - Wraps error message sending in nested try-catch to handle send failures gracefully
    - Logs send errors but doesn't re-raise them
- The `extractChatInfoFromUpdate` helper method may be implemented in a later task (PHASE2-063), but should be used here if available
- Error handling must be robust: log errors, attempt user notification, but always return 200 OK
- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE2-055
- Next: PHASE2-057

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
