# PHASE2-014: Create async processing utilities

**Section**: 3. Async Processing Setup
**Subsection**: 3.3
**Task ID**: PHASE2-014

## Description

Create async processing utilities that provide helper functions for asynchronous operations. Since this application doesn't use a queue system, we leverage Node.js's native async capabilities with proper error handling, retry logic, and timeout management.

**Rails Implementation Reference:**

- `jarek-va/config/initializers/sidekiq.rb` - Sidekiq Redis connection configuration (lines 7-10 for server, lines 24-27 for client)
  - Both server and client configurations use the same Redis URL from `REDIS_URL` environment variable
  - Defaults to `redis://localhost:6379/0` if `REDIS_URL` is not set
  - In Docker: `REDIS_URL` is set to `redis://redis:6379/0` (shared Redis instance)

**Node.js Implementation:**

- Create `src/utils/async.ts` to provide async processing utilities
- Implement retry logic with exponential backoff
- Implement timeout handling for async operations
- Implement concurrency control utilities
- Export utilities for reuse across the application
- This utility complements `src/config/async.ts` (created in PHASE2-013) by providing the actual implementation functions

## Checklist

- [ ] Create `src/utils/async.ts` file
- [ ] Implement retry utility with exponential backoff:
  - [ ] Create `withRetry<T>(fn: () => Promise<T>, options?: RetryOptions): Promise<T>` function
  - [ ] Support configurable retry attempts (default: 3)
  - [ ] Implement exponential backoff delay calculation
  - [ ] Handle specific error types that should not be retried
  - [ ] Log retry attempts appropriately
- [ ] Implement timeout utility:
  - [ ] Create `withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T>` function
  - [ ] Throw timeout error if operation exceeds timeout
  - [ ] Clean up resources on timeout
- [ ] Implement concurrency control utilities:
  - [ ] Create `withConcurrencyLimit<T>(tasks: (() => Promise<T>)[], limit: number): Promise<T[]>` function
  - [ ] Process tasks in batches respecting concurrency limit
  - [ ] Use Promise-based semaphore pattern
- [ ] Add error handling:
  - [ ] Ensure all utilities handle errors gracefully
  - [ ] Log errors with full stack traces
  - [ ] Export error types for specific error handling
- [ ] Add TypeScript types:
  - [ ] Define `RetryOptions` interface
  - [ ] Define `AsyncResult<T>` type for results
  - [ ] Type all utility functions properly
- [ ] Export utilities:
  - [ ] Export `withRetry` function
  - [ ] Export `withTimeout` function
  - [ ] Export `withConcurrencyLimit` function
  - [ ] Export related types and interfaces

## Notes

- This task is part of Phase 2: File-by-File Conversion
- Section: 3. Async Processing Setup
- **Rails Files to Reference:**
  - `jarek-va/config/initializers/sidekiq.rb` - Sidekiq Redis connection:
    - Server configuration (lines 7-10): `config.redis = { url: ENV.fetch('REDIS_URL', 'redis://localhost:6379/0') }`
    - Client configuration (lines 24-27): Same Redis URL configuration
    - Both use the same Redis instance (shared connection pattern)
    - Environment variable: `REDIS_URL` (defaults to `redis://localhost:6379/0`)
    - In Docker: `REDIS_URL=redis://redis:6379/0` (shared Redis instance)
- **Dependencies:**
  - Requires async configuration to exist (completed in PHASE2-013)
  - No external queue dependencies required (using Node.js native async)
  - Note: This is separate from the Redis connection utility (`src/utils/redis.ts` from PHASE2-009). The Redis utility provides direct Redis client access for other services, while this utility provides async processing helpers.
- **Implementation Details:**
  - Since this application doesn't use a queue system, we use Node.js native async/await patterns
  - Retry logic should match Rails behavior: 3 attempts with exponential backoff (matching Sidekiq's `wait: :exponentially_longer`)
  - Exponential backoff: delay = baseDelay * (2 ^ attemptNumber), e.g., 2000ms, 4000ms, 8000ms
  - Timeout handling should use `Promise.race()` pattern with a timeout promise
  - Concurrency control can use semaphore pattern or `Promise.all()` with batching
  - This utility is separate from `src/config/async.ts` (PHASE2-013):
    - `src/config/async.ts`: Configuration settings (default options, environment-specific settings)
    - `src/utils/async.ts`: Implementation functions (retry, timeout, concurrency control)
- **Key Differences from Rails:**
  - Rails: Sidekiq manages job processing with Redis queues and workers
  - Node.js: Uses native async/await with Promise-based patterns (no queue system needed)
  - Rails: Connection is configured globally in initializer
  - Node.js: Async utilities are imported and used directly where needed
- **Usage Pattern:**
  - Other modules will import: `import { withRetry, withTimeout, withConcurrencyLimit } from '@/utils/async'`
  - For retry: `await withRetry(() => someAsyncOperation(), { attempts: 3 })`
  - For timeout: `await withTimeout(someAsyncOperation(), 5000)`
  - For concurrency: `await withConcurrencyLimit(tasks, 5)`
- **Testing Considerations:**
  - Test that retry logic works correctly with exponential backoff
  - Test that timeout throws error after timeout period
  - Test that concurrency limit is respected
  - Test error handling in all utilities
  - Test that utilities can be composed together
- Task can be completed independently by a single agent (after PHASE2-013 is complete)

## Related Tasks

- Previous: PHASE2-013
- Next: PHASE2-015

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

