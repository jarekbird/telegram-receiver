# PHASE2-093: Register all routes in main app

**Section**: 11. Routes Configuration
**Subsection**: 11.5
**Task ID**: PHASE2-093

## Description

Register all routes in the main Express.js application, converting from Rails routes configuration. This task updates `src/index.ts` to import and mount all route modules that were created in previous tasks (PHASE2-089 through PHASE2-092).

Reference `jarek-va/config/routes.rb` for the complete route structure. The Rails application defines the following route groups that must all be registered:

1. **Health routes**: `GET /health` and `GET /` (root) - from `src/routes/health.routes.ts`
2. **Agent tools route**: `POST /agent-tools` - from `src/routes/agent-tools.routes.ts`
3. **Cursor-runner routes**: Multiple endpoints under `/cursor-runner` scope - from `src/routes/cursor-runner.routes.ts`
   - `POST /cursor-runner/cursor/execute`
   - `POST /cursor-runner/cursor/iterate`
   - `POST /cursor-runner/callback`
   - `POST /cursor-runner/git/clone`
   - `GET /cursor-runner/git/repositories`
   - `POST /cursor-runner/git/checkout`
   - `POST /cursor-runner/git/push`
   - `POST /cursor-runner/git/pull`
4. **Telegram routes**: Multiple endpoints under `/telegram` scope - from `src/routes/telegram.routes.ts`
   - `POST /telegram/webhook`
   - `POST /telegram/set_webhook`
   - `GET /telegram/webhook_info`
   - `DELETE /telegram/webhook`

**Note**: The Rails application also mounts Sidekiq Web UI at `/sidekiq` (line 40 in `routes.rb`). Since Sidekiq is Ruby-specific, this route is not included in this conversion task. A Node.js equivalent (e.g., BullMQ dashboard) should be implemented in a separate task if background job monitoring UI is needed.

## Rails Implementation Reference

From `jarek-va/config/routes.rb`:

```ruby
Rails.application.routes.draw do
  # Health check endpoint
  get 'health', to: 'health#show'
  root 'health#show'

  # Agent tools webhook endpoint
  post 'agent-tools', to: 'agent_tools#create'

  # cursor-runner API endpoints
  scope path: 'cursor-runner', as: 'cursor_runner' do
    # Cursor execution endpoints
    post 'cursor/execute', to: 'cursor_runner#execute'
    post 'cursor/iterate', to: 'cursor_runner#iterate'

    # Webhook callback endpoint (receives callbacks from cursor-runner)
    post 'callback', to: 'cursor_runner_callback#create'

    # Git operation endpoints
    post 'git/clone', to: 'cursor_runner#clone'
    get 'git/repositories', to: 'cursor_runner#repositories'
    post 'git/checkout', to: 'cursor_runner#checkout'
    post 'git/push', to: 'cursor_runner#push'
    post 'git/pull', to: 'cursor_runner#pull'
  end

  # Telegram webhook endpoints
  scope path: 'telegram', as: 'telegram' do
    post 'webhook', to: 'telegram#webhook'
    post 'set_webhook', to: 'telegram#set_webhook'
    get 'webhook_info', to: 'telegram#webhook_info'
    delete 'webhook', to: 'telegram#delete_webhook'
  end

  # Sidekiq Web UI (mount in development/staging only, protect in production)
  require 'sidekiq/web'
  mount Sidekiq::Web => '/sidekiq'
end
```

**Note**: The Sidekiq Web UI mount is Ruby-specific and not included in this conversion task. A Node.js equivalent (e.g., BullMQ dashboard) should be implemented separately if background job monitoring UI is needed.

## Checklist

- [ ] Update `src/index.ts` (main application entry point)
- [ ] Import Express and create Express app instance
- [ ] Import all route modules:
  - [ ] Import health routes from `./routes/health.routes`
  - [ ] Import agent-tools routes from `./routes/agent-tools.routes`
  - [ ] Import cursor-runner routes from `./routes/cursor-runner.routes`
  - [ ] Import telegram routes from `./routes/telegram.routes`
- [ ] Register/mount all routes with correct path prefixes:
  - [ ] Mount health routes at root (`/`) - handles both `/health` and `/`
  - [ ] Mount agent-tools routes at `/agent-tools`
  - [ ] Mount cursor-runner routes at `/cursor-runner`
  - [ ] Mount telegram routes at `/telegram`
- [ ] Apply global middleware (if any):
  - [ ] JSON body parser middleware
  - [ ] Error handling middleware
  - [ ] Request logging middleware (if needed)
- [ ] Start Express server on configured port
- [ ] Handle server startup errors appropriately
- [ ] Export Express app instance for testing purposes

## Implementation Notes

### Express App Setup Pattern

The `src/index.ts` file should follow this pattern:

```typescript
import express, { Express } from 'express';
import healthRoutes from './routes/health.routes';
import agentToolsRoutes from './routes/agent-tools.routes';
import cursorRunnerRoutes from './routes/cursor-runner.routes';
import telegramRoutes from './routes/telegram.routes';

const app: Express = express();
const PORT = process.env.PORT || 3000;

// Global middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Mount routes
app.use('/', healthRoutes);
app.use('/agent-tools', agentToolsRoutes);
app.use('/cursor-runner', cursorRunnerRoutes);
app.use('/telegram', telegramRoutes);

// Error handling middleware (if needed)
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  console.error('Error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

// Start server
app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

export default app;
```

### Route Mounting Order

Routes should be mounted in this order:

1. Health routes first (at root `/`) - for health checks
2. Agent tools routes (at `/agent-tools`)
3. Cursor-runner routes (at `/cursor-runner`)
4. Telegram routes (at `/telegram`)

### Environment Configuration

- Port should be configurable via `process.env.PORT` (defaults to 3000)
- Other environment variables may be needed for route handlers (handled in controllers)

### Route File Naming

- Health routes: `health.routes.ts` (note: dot notation, not hyphen)
- Agent tools routes: `agent-tools.routes.ts` (hyphen notation)
- Cursor-runner routes: `cursor-runner.routes.ts` (hyphen notation)
- Telegram routes: `telegram.routes.ts` (dot notation)

## Notes

- This task is part of Phase 2: File-by-File Conversion
- Section: 11. Routes Configuration
- Subsection: 11.5
- This task assumes route files have been created in previous tasks (PHASE2-089 through PHASE2-092)
- Route files should already exist:
  - `src/routes/health.routes.ts` (created in PHASE2-090)
  - `src/routes/agent-tools.routes.ts` (created in PHASE2-089)
  - `src/routes/cursor-runner.routes.ts` (created in PHASE2-089, callback route added in PHASE2-092)
  - `src/routes/telegram.routes.ts` (created in PHASE2-091) - **Note**: PHASE2-091 mentions `telegram-routes.ts` but should be `telegram.routes.ts` to match naming convention used in PHASE2-089
- Reference the Rails implementation (`jarek-va/config/routes.rb`) for exact route structure
- The main application entry point (`src/index.ts`) is currently empty and needs to be fully implemented
- Global middleware (JSON parser, error handling) should be applied before route mounting
- **Sidekiq Web UI**: The Rails application mounts Sidekiq Web UI at `/sidekiq` (line 40 in `routes.rb`), but this is Ruby-specific and not included in this conversion. A Node.js equivalent (e.g., BullMQ dashboard) should be implemented separately if needed.
- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE2-092
- Next: PHASE2-094

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

