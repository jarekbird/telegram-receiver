# PHASE1-039: Create docker-compose.prod.yml for production

**Section**: 9. Docker Configuration
**Subsection**: 9.4
**Task ID**: PHASE1-039

## Description

Create a production docker-compose.prod.yml file for the telegram-receiver Node.js/TypeScript application. The docker-compose.prod.yml should configure all services needed for production deployment, including the application service, Redis service (for BullMQ job queue), Traefik reverse proxy for SSL termination, worker service for background jobs, shared volumes, and production-specific settings. Reference the jarek-va docker-compose.yml (`/cursor/repositories/jarek-va/docker-compose.yml`) for patterns, but adapt for Node.js/TypeScript production needs.

## Checklist

- [ ] Create `docker-compose.prod.yml` file in project root
- [ ] Define `traefik` service (reverse proxy for SSL termination):
  - [ ] Use `traefik:v2.11` image (matching jarek-va)
  - [ ] Set container name to `telegram-receiver-traefik` (or similar)
  - [ ] Configure command flags (matching jarek-va pattern):
    - [ ] `--api.dashboard=true` (enable dashboard)
    - [ ] `--api.insecure=true` (set to false and add auth in production for security)
    - [ ] `--providers.docker=true` (enable Docker provider)
    - [ ] `--providers.docker.exposedbydefault=false` (only expose services with traefik.enable=true)
    - [ ] `--entrypoints.web.address=:80` (HTTP entrypoint)
    - [ ] `--entrypoints.websecure.address=:443` (HTTPS entrypoint)
    - [ ] `--certificatesresolvers.letsencrypt.acme.tlschallenge=true` (enable TLS challenge)
    - [ ] `--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL:-admin@example.com}` (ACME email)
    - [ ] `--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json` (certificate storage)
    - [ ] `--entrypoints.web.http.redirections.entrypoint.to=websecure` (HTTP to HTTPS redirect)
    - [ ] `--entrypoints.web.http.redirections.entrypoint.scheme=https` (redirect scheme)
  - [ ] Mount Docker socket (`/var/run/docker.sock:/var/run/docker.sock:ro`) for service discovery
  - [ ] Mount letsencrypt volume (`./letsencrypt:/letsencrypt`) for certificate storage
  - [ ] Set restart policy to `unless-stopped`
  - [ ] Add to `virtual-assistant-network` network
  - [ ] Expose ports 80, 443, and 8080 (dashboard - secure dashboard access in production)
- [ ] Define `redis` service:
  - [ ] Use `redis:7-alpine` image (matching jarek-va)
  - [ ] Set container name to `telegram-receiver-redis` (or similar)
  - [ ] Configure Redis persistence with command `redis-server --appendonly yes` (matching jarek-va)
  - [ ] **Do NOT expose Redis port 6379** in production (Redis is accessed internally via Docker network)
  - [ ] Add volume for Redis data persistence (`shared_redis_data:/data`)
  - [ ] Set restart policy to `unless-stopped`
  - [ ] Add healthcheck using `redis-cli ping` with parameters (matching jarek-va):
    - [ ] Test: `["CMD", "redis-cli", "ping"]`
    - [ ] Interval: `10s`
    - [ ] Timeout: `5s`
    - [ ] Retries: `5`
  - [ ] Add to `virtual-assistant-network` network
- [ ] Define `app` service:
  - [ ] Set build context to current directory (`.`)
  - [ ] Set dockerfile path to `Dockerfile`
  - [ ] Set container name to `telegram-receiver-app` (or similar)
  - [ ] **Do NOT expose ports directly** - Traefik will route traffic
  - [ ] Set `NODE_ENV` environment variable to `production`
  - [ ] Set `PORT` environment variable to `3000`
  - [ ] Set `REDIS_URL` to `redis://redis:6379/0` (using Redis service name, with database number `/0` to match jarek-va pattern)
  - [ ] Set `CURSOR_RUNNER_URL` to `http://cursor-runner:3001`
  - [ ] Set `CURSOR_RUNNER_TIMEOUT` to `${CURSOR_RUNNER_TIMEOUT:-300}`
  - [ ] Set other production environment variables (TELEGRAM_BOT_TOKEN, LOG_LEVEL=info, etc.)
  - [ ] Add volume mount for shared SQLite database (`shared_sqlite_db:/app/shared_db`)
  - [ ] Add volume mount for logs (`./log:/app/log`) if needed
  - [ ] Set restart policy to `unless-stopped`
  - [ ] Add depends_on for `redis` and `traefik` services
  - [ ] Add to `virtual-assistant-network` network
  - [ ] Add Traefik labels for routing:
    - [ ] `traefik.enable=true`
    - [ ] Router rule: `Host(\`${DOMAIN_NAME:-localhost}\`) && !PathPrefix(\`/agents\`)`
    - [ ] Entrypoint: `websecure` (HTTPS)
    - [ ] TLS cert resolver: `letsencrypt`
    - [ ] Service port: `3000`
    - [ ] Security headers middleware (SSL redirect, HSTS, etc.)
  - [ ] Add healthcheck (matching jarek-va pattern):
    - [ ] Test: `["CMD", "curl", "-f", "http://localhost:3000/health"]`
    - [ ] Interval: `30s`
    - [ ] Timeout: `10s`
    - [ ] Retries: `3`
    - [ ] Start period: `10s` (allow time for app to start)
- [ ] Define `worker` service (BullMQ worker for background jobs):
  - [ ] Set build context to current directory (`.`)
  - [ ] Set dockerfile path to `Dockerfile`
  - [ ] Set container name to `telegram-receiver-worker` (or similar)
  - [ ] Set command to run BullMQ worker (e.g., `npm run worker` or `node dist/worker.js`)
    - [ ] **Note**: The worker script/entry point must be created separately (e.g., add `"worker": "node dist/worker.js"` to package.json scripts, or create `dist/worker.js` entry point)
  - [ ] Set `NODE_ENV` environment variable to `production`
  - [ ] Set `REDIS_URL` to `redis://redis:6379/0` (with database number `/0` to match jarek-va pattern)
  - [ ] Set `CURSOR_RUNNER_URL` to `http://cursor-runner:3001`
  - [ ] Set other production environment variables matching `app` service
  - [ ] Add volume mount for shared SQLite database (`shared_sqlite_db:/app/shared_db`)
  - [ ] Add volume mount for logs (`./log:/app/log`) if needed
  - [ ] Set restart policy to `unless-stopped`
  - [ ] Add depends_on for `redis` and `app` services
  - [ ] Add to `virtual-assistant-network` network
- [ ] Define volumes:
  - [ ] `shared_redis_data` volume (driver: local, name: shared_redis_data)
  - [ ] `shared_sqlite_db` volume (driver: local, name: shared_sqlite_db)
- [ ] Define networks:
  - [ ] Reference `virtual-assistant-network` as external network (matching jarek-va)
  - [ ] Network name: `virtual-assistant-network`
- [ ] Add production-specific configurations:
  - [ ] Ensure no source code volume mounts (production uses built image)
  - [ ] Configure logging to stdout for Docker logging
  - [ ] Set appropriate healthcheck intervals and timeouts
  - [ ] Ensure security headers are configured via Traefik middleware

## Notes

- This task is part of Phase 1: Basic Node.js API Infrastructure
- Section: 9. Docker Configuration
- Task can be completed independently by a single agent
- Reference the jarek-va docker-compose.yml (`/cursor/repositories/jarek-va/docker-compose.yml`) for patterns:
  - Traefik reverse proxy configuration
  - Redis service configuration
  - Shared volume setup (Redis data, SQLite database)
  - Network configuration
  - Healthcheck patterns
  - Traefik labels for routing and SSL
  - Security headers middleware
- The production docker-compose.prod.yml should:
  - Use Traefik for SSL termination and routing (no direct port exposure)
  - Include Redis for BullMQ job queue
  - Include worker service for background job processing
  - Use shared volumes for Redis data and SQLite database
  - Connect to `virtual-assistant-network` for service communication
  - Configure production environment variables (NODE_ENV=production, LOG_LEVEL=info)
  - Include healthchecks for all services
  - Set restart policies to `unless-stopped` for production reliability
- Environment variables should match those defined in `.env.example`:
  - `NODE_ENV=production`
  - `PORT=3000`
  - `REDIS_URL=redis://redis:6379/0` (with database number `/0` to match jarek-va pattern)
  - `CURSOR_RUNNER_URL=http://cursor-runner:3001`
  - `CURSOR_RUNNER_TIMEOUT=300`
  - `TELEGRAM_BOT_TOKEN` (from environment)
  - `LOG_LEVEL=info` (for production)
  - `ACME_EMAIL` (for Let's Encrypt certificate registration, defaults to `admin@example.com` if not set)
  - `DOMAIN_NAME` (domain name for Traefik routing, defaults to `localhost` if not set)
- The app service should NOT expose ports directly - Traefik handles routing
- The worker service runs background jobs using BullMQ (equivalent to Sidekiq in Rails)
- Shared volumes enable cross-service access to Redis data and SQLite database
- Traefik labels configure HTTPS routing, SSL certificates, and security headers
- Redis port 6379 should NOT be exposed in production (Redis is accessed internally via Docker network for security)
- Traefik dashboard (port 8080) should be secured in production by setting `--api.insecure=false` and adding authentication
- Healthcheck intervals and timeouts match jarek-va patterns for consistency and reliability
- The worker service command assumes a worker script/entry point exists (may need to be created in a separate task)

## Related Tasks

- Previous: PHASE1-038
- Next: PHASE1-040

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

