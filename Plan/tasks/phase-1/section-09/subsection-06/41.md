# PHASE1-041: Test docker-compose.prod.yml

**Section**: 9. Docker Configuration
**Subsection**: 9.6
**Task ID**: PHASE1-041

## Description

Test the docker-compose.prod.yml configuration for the telegram-receiver Node.js/TypeScript application. This task verifies that all services defined in docker-compose.prod.yml (created in PHASE1-039) start correctly, communicate properly, and function as expected. This includes testing Traefik reverse proxy, Redis service, application service, worker service, shared volumes, network connectivity, health checks, and proper service shutdown. This ensures the docker-compose configuration is correct and ready for production deployment.

**Note**: The curl commands in this task are for Docker deployment verification only. For development testing, use automated tests (`npm test`, `npm run test:integration`) instead of running the server manually.

## Prerequisites

- PHASE1-039 (Create docker-compose.prod.yml) must be completed
- PHASE1-040 (Test Docker build) must be completed
- docker-compose.prod.yml must exist in the project root
- Dockerfile must exist and build successfully
- `.dockerignore` file should exist (from PHASE1-037)
- `virtual-assistant-network` Docker network must exist (create with `docker network create virtual-assistant-network` if needed)

## Checklist

- [ ] Verify `docker-compose.prod.yml` exists in project root
- [ ] Verify `Dockerfile` exists (from PHASE1-036)
- [ ] Verify `.dockerignore` file exists (from PHASE1-037)
- [ ] Verify `virtual-assistant-network` exists: `docker network ls | grep virtual-assistant-network`
  - [ ] If missing, create it: `docker network create virtual-assistant-network`
- [ ] Verify worker script/entry point exists (required for worker service):
  - [ ] Check if `package.json` has `"worker"` script defined, OR
  - [ ] Verify worker entry point exists (e.g., `dist/worker.js` or `src/worker.ts`)
  - [ ] Note: If worker script doesn't exist, it must be created before testing (see PHASE1-039 notes)
- [ ] Set up required environment variables (create `.env` file or export):
  - [ ] `DOMAIN_NAME` (e.g., `localhost` for testing)
  - [ ] `ACME_EMAIL` (for Let's Encrypt, e.g., `admin@example.com`)
  - [ ] `TELEGRAM_BOT_TOKEN` (if needed for app startup)
  - [ ] `CURSOR_RUNNER_TIMEOUT` (optional, defaults to 300)
- [ ] Run `docker-compose -f docker-compose.prod.yml up --build -d` (detached mode)
- [ ] Wait for all services to start (check logs: `docker-compose -f docker-compose.prod.yml logs`)
- [ ] Verify all containers are running: `docker-compose -f docker-compose.prod.yml ps`
  - [ ] `telegram-receiver-traefik` container should be running
  - [ ] `telegram-receiver-redis` container should be running
  - [ ] `telegram-receiver-app` container should be running
  - [ ] `telegram-receiver-worker` container should be running
- [ ] Check Traefik service:
  - [ ] Verify Traefik container logs show no errors: `docker logs telegram-receiver-traefik`
  - [ ] Verify Traefik dashboard is accessible (if enabled): `curl http://localhost:8080` (optional)
- [ ] Check Redis service:
  - [ ] Verify Redis container logs show no errors: `docker logs telegram-receiver-redis`
  - [ ] Test Redis connectivity: `docker exec telegram-receiver-redis redis-cli ping` (should return `PONG`)
  - [ ] Verify Redis healthcheck passed: `docker inspect telegram-receiver-redis | grep -A 5 Health`
- [ ] Check application service:
  - [ ] Verify app container logs show no errors: `docker logs telegram-receiver-app`
  - [ ] Verify app container logs show application started successfully
  - [ ] Test health endpoint via Traefik: `curl -k https://localhost/health` (or `curl http://localhost/health` if HTTP redirect works)
  - [ ] Test health endpoint directly (if port exposed for testing): `curl http://localhost:3000/health` (should return 200 OK)
  - [ ] Verify health endpoint response contains expected JSON structure (matching Rails implementation):
    - [ ] `status: "healthy"` (must be exactly "healthy")
    - [ ] `service: "telegram-receiver"` (service name)
    - [ ] `version: "..."` (version number, e.g., "1.0.0")
  - [ ] Verify app healthcheck passed: `docker inspect telegram-receiver-app | grep -A 5 Health`
- [ ] Check worker service:
  - [ ] Verify worker container logs show no errors: `docker logs telegram-receiver-worker`
  - [ ] Verify worker container logs show worker started successfully
  - [ ] Verify worker can connect to Redis (check logs for connection success)
  - [ ] Verify worker process is running: `docker exec telegram-receiver-worker ps aux | grep -E "(node|worker)"`
- [ ] Verify network connectivity:
  - [ ] Verify all containers are on `virtual-assistant-network`: `docker network inspect virtual-assistant-network`
  - [ ] Test app can reach Redis: `docker exec telegram-receiver-app ping -c 1 redis` (or test Redis connection from app)
  - [ ] Test app can reach cursor-runner (if available):
    - [ ] Verify `CURSOR_RUNNER_URL` environment variable is set correctly: `docker exec telegram-receiver-app env | grep CURSOR_RUNNER_URL` (should show `CURSOR_RUNNER_URL=http://cursor-runner:3001`)
    - [ ] (Optional) Test connectivity: `docker exec telegram-receiver-app ping -c 1 cursor-runner` (if cursor-runner service is running)
- [ ] Verify volumes:
  - [ ] Verify `shared_redis_data` volume exists: `docker volume ls | grep shared_redis_data`
  - [ ] Verify `shared_sqlite_db` volume exists: `docker volume ls | grep shared_sqlite_db`
  - [ ] Verify volumes are mounted correctly in containers: `docker inspect telegram-receiver-redis | grep -A 10 Mounts`
- [ ] Test service dependencies:
  - [ ] Verify app service waits for Redis (check startup logs for connection retries if Redis was slow)
  - [ ] Verify worker service waits for Redis and app (check startup order)
- [ ] Test graceful shutdown:
  - [ ] Run `docker-compose -f docker-compose.prod.yml stop` (graceful stop)
  - [ ] Verify all containers stop gracefully: `docker-compose -f docker-compose.prod.yml ps` (should show exited)
  - [ ] Run `docker-compose -f docker-compose.prod.yml down` (remove containers)
  - [ ] Verify containers are removed: `docker ps -a | grep telegram-receiver` (should show no containers)
  - [ ] (Optional) Remove volumes: `docker-compose -f docker-compose.prod.yml down -v` (if testing cleanup)
  - [ ] (Optional) Remove images: `docker-compose -f docker-compose.prod.yml down --rmi all` (if testing full cleanup)

## Notes

- This task is part of Phase 1: Basic Node.js API Infrastructure
- Section: 9. Docker Configuration
- Task can be completed independently by a single agent
- **Prerequisites**: This task requires PHASE1-039 (Create docker-compose.prod.yml) and PHASE1-040 (Test Docker build) to be completed first
- Use `docker-compose -f docker-compose.prod.yml` to specify the production compose file
- The `virtual-assistant-network` must exist before starting services (create with `docker network create virtual-assistant-network` if needed)
- For local testing, you may need to:
  - Set `DOMAIN_NAME=localhost` in environment
  - Use self-signed certificates or disable SSL verification for testing (`curl -k`)
  - Access services directly via exposed ports if Traefik routing doesn't work in local environment
- Health checks may take time to pass - wait at least 30 seconds after starting services before checking health status
- If services fail to start, check:
  - Network exists and is accessible
  - Environment variables are set correctly
  - Ports are not already in use (especially 80, 443, 3000, 6379, 8080)
  - Docker has sufficient resources (memory, disk space)
  - Dockerfile builds successfully (tested in PHASE1-040)
- Traefik may require domain name configuration for SSL - for local testing, you may need to adjust Traefik labels or use HTTP only
- Redis must be accessible from both app and worker services
- Shared volumes enable data persistence across container restarts
- After testing, clean up containers, networks, and optionally volumes to avoid cluttering Docker
- The worker service should start successfully even if no jobs are queued
- All services should have proper restart policies (`unless-stopped`) for production reliability
- **Worker Script Requirement**: The worker service requires a worker script/entry point to exist. This may be created in a separate task (as noted in PHASE1-039). Before testing, verify that either:
  - `package.json` has a `"worker"` script (e.g., `"worker": "node dist/worker.js"`), OR
  - A worker entry point file exists (e.g., `dist/worker.js` or `src/worker.ts`)
- Health endpoint JSON structure must match the Rails implementation format: `{"status": "healthy", "service": "telegram-receiver", "version": "1.0.0"}` (see PHASE1-040 for reference)

## Related Tasks

- Previous: PHASE1-040
- Next: PHASE1-042

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

