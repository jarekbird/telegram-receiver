# PHASE1-028: Use environment config in application

**Section**: 7. Environment Variables Management
**Subsection**: 7.6
**Task ID**: PHASE1-028

## Description

Integrate the environment configuration module into the main application entry point (`src/index.ts`) to use environment variables for server port and environment logging. This task imports the Express app from `src/app.ts`, starts the Express server using the port from the environment configuration, and logs both the environment and port when the server starts.

In Rails, the server port is configured in `config/puma.rb` using `ENV.fetch("PORT") { 3000 }`, and the environment is accessed via `ENV.fetch("RAILS_ENV") { "development" }`. When Puma (the Rails web server) starts, it logs the environment and port information. This task replicates that behavior in the Node.js application by using the centralized environment configuration module created in PHASE1-024.

**Rails Equivalent**: `jarek-va/config/puma.rb` (lines 18, 22) - Rails uses `ENV.fetch("PORT") { 3000 }` for port configuration and `ENV.fetch("RAILS_ENV") { "development" }` for environment. When Puma starts, it logs the environment and port information.

**Note**: This task assumes that `src/app.ts` exists (created in PHASE1-015) and exports the Express app instance. The task also assumes that `src/config/environment.ts` exists (created in PHASE1-024) and exports a `config` object with `port` and `env` properties.

## Checklist

- [ ] Open `src/index.ts` (create if it doesn't exist)
- [ ] Import the Express app from `./app` (default export from `src/app.ts` created in PHASE1-015)
- [ ] Import config from `./config/environment` (default export from `src/config/environment.ts` created in PHASE1-024)
- [ ] Start the Express server using `app.listen(config.port, ...)` with the port from config
- [ ] Log the environment and port when server starts (e.g., `console.log(`Server running in ${config.env} mode on port ${config.port}`)`)
- [ ] Add error handling for server startup:
  - Handle port binding errors (EADDRINUSE - port already in use)
  - Handle permission errors (EACCES - permission denied)
  - Handle other server startup errors
  - Log appropriate error messages and exit gracefully on fatal errors

## Notes

- This task is part of Phase 1: Basic Node.js API Infrastructure
- Section: 7. Environment Variables Management
- Task can be completed independently by a single agent
- **Rails Equivalent**: `jarek-va/config/puma.rb` (lines 18, 22) - Rails uses `ENV.fetch("PORT") { 3000 }` for port configuration and `ENV.fetch("RAILS_ENV") { "development" }` for environment
- **Dependencies**:
  - Requires `src/app.ts` to exist (created in PHASE1-015) and export the Express app instance
  - Requires `src/config/environment.ts` to exist (created in PHASE1-024) and export a `config` object with `port` and `env` properties
- **Server Startup**: The `src/index.ts` file is the main entry point that starts the Express server. It should import the app from `src/app.ts` and start listening on the configured port
- **Environment Logging**: Logging both the environment and port when the server starts helps with debugging and confirms which environment and port the application is running on, similar to how Puma logs this information on startup
- **Port Configuration**: The port comes from the environment configuration module, which reads from `process.env.PORT` or defaults to 3000 (matching Rails default port)
- **Error Handling**: The server startup should handle errors such as:
  - `EADDRINUSE`: Port already in use - log error and exit with appropriate code
  - `EACCES`: Permission denied - log error and exit with appropriate code
  - Other server startup errors - log error details and exit gracefully
  - Use `process.exit(1)` for fatal errors to indicate failure

## Related Tasks

- Previous: PHASE1-027
- Next: PHASE1-029

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

