# PHASE4-007: Check for code smells (long methods, large classes, etc.)

**Section**: 1. Automated Code Smell Detection
**Subsection**: 1.7
**Task ID**: PHASE4-007

## Description

Run comprehensive code smell detection to identify common code quality issues such as long methods, large classes, deep nesting, magic numbers, and other code smells that impact maintainability and code quality. This task focuses on detecting structural code smells and providing actionable insights for refactoring.

## Current State

The project currently has:

- **ESLint** configured with TypeScript rules (PHASE4-001)
- **Prettier** configured for code formatting (PHASE4-002)
- **SonarQube or similar tool** may be set up (PHASE4-003)
- **Complexity analysis** may be completed (PHASE4-004)
- **Code duplication detection** may be completed (PHASE4-005)
- **Unused code detection** may be completed (PHASE4-006)
- Basic linting and formatting scripts in package.json

**Existing Code Smell Detection**:

- ESLint is configured but does NOT currently have complexity rules enabled (no `complexity`, `max-depth`, `max-lines-per-function`, `max-params` rules)
- TypeScript compiler provides basic checks
- Both tools provide basic detection but may miss:
  - Long methods (methods exceeding recommended line count)
  - Large classes/files (classes/files exceeding recommended size)
  - Deep nesting (excessive control flow nesting)
  - Magic numbers (hardcoded numeric values without constants)
  - Code smell patterns (god classes, feature envy, long parameter lists, etc.)
  - Code quality metrics and thresholds

**Missing**: Comprehensive code smell detection that provides:

- Identification of long methods (>50 lines)
- Identification of large classes/files (>500 lines)
- Detection of deep nesting (>4 levels)
- Detection of magic numbers
- Detection of common code smell patterns
- Prioritization of code smells by severity
- Integration with existing tooling (ESLint, SonarQube)
- Automated code smell reporting
- Code quality metrics and thresholds

## Tool Options

Consider the following options for code smell detection:

1. **SonarJS/SonarQube** (Recommended if PHASE4-003 is completed)
   - Built-in code smell detection
   - Detects long methods, large classes, deep nesting
   - Identifies magic numbers
   - Provides code smell ratings
   - Integration with existing SonarQube setup
   - Visual reports and dashboards

2. **ESLint plugins** (Recommended for integration)
   - Built-in ESLint rules: `complexity`, `max-depth`, `max-lines-per-function`, `max-params` - Cyclomatic complexity and size detection
   - `eslint-plugin-sonarjs` - SonarJS rules for ESLint (comprehensive code smell detection)
   - `eslint-plugin-no-magic-numbers` - Magic number detection
   - Integrates with existing ESLint setup
   - Can be configured with thresholds

3. **CodeClimate** (Cloud-based)
   - Comprehensive code smell detection
   - Provides code quality ratings
   - Integrates with GitHub/GitLab
   - Free for open source projects

4. **jsinspect** (Code smell detection)
   - Detects code smells and anti-patterns
   - Identifies similar code patterns
   - Command-line tool
   - Can be integrated into npm scripts

5. **ts-morph** (TypeScript-specific)
   - TypeScript AST analysis
   - Can detect structural code smells
   - Programmatic analysis capabilities

6. **Custom ESLint rules**
   - Can create custom rules for project-specific smells
   - Integrates with existing ESLint setup
   - Requires development effort

## Code Smell Thresholds

Recommended thresholds for code smell detection:

### Method/Function Size

- **Excellent**: < 20 lines
- **Good**: 20-50 lines
- **Acceptable**: 50-100 lines
- **Needs refactoring**: > 100 lines
- **Threshold for detection**: > 50 lines

### Class/File Size

- **Excellent**: < 200 lines
- **Good**: 200-500 lines
- **Acceptable**: 500-1000 lines
- **Needs refactoring**: > 1000 lines
- **Threshold for detection**: > 500 lines

### Nesting Depth

- **Excellent**: < 3 levels
- **Good**: 3-4 levels
- **Acceptable**: 4-5 levels
- **Needs refactoring**: > 5 levels
- **Threshold for detection**: > 4 levels

### Cyclomatic Complexity

- **Excellent**: < 10
- **Good**: 10-20
- **Acceptable**: 20-30
- **Needs refactoring**: > 30
- **Threshold for detection**: > 15

### Magic Numbers

- **Threshold**: Any numeric literal that should be a named constant
- **Exceptions**: 0, 1, -1 (common in loops/conditions)
- **Exceptions**: Common mathematical constants (Math.PI, etc.)

## Checklist

### Tool Selection and Setup

- [ ] Research and compare code smell detection tool options
- [ ] Choose appropriate tool(s) based on project needs and existing setup
- [ ] Install chosen tool(s) as dev dependencies (if npm packages)
- [ ] Configure tool with appropriate thresholds and ignore patterns
- [ ] Add code smell detection script to package.json
- [ ] Configure ignore patterns (node_modules, dist, coverage, tests if desired)
- [ ] Test tool configuration on codebase

### ESLint Plugin Configuration (Recommended)

- [ ] Install eslint-plugin-sonarjs: `npm install --save-dev eslint-plugin-sonarjs`
- [ ] Install eslint-plugin-no-magic-numbers: `npm install --save-dev eslint-plugin-no-magic-numbers`
- [ ] Update `.eslintrc.json` to include the plugins
- [ ] Configure built-in ESLint complexity rules:
  - `complexity: ["warn", 15]` - Warn on cyclomatic complexity > 15
  - `max-depth: ["warn", 4]` - Warn on nesting depth > 4
  - `max-lines-per-function: ["warn", { max: 50, skipBlankLines: true, skipComments: true }]` - Warn on functions > 50 lines
  - `max-params: ["warn", 5]` - Warn on functions with > 5 parameters
- [ ] Configure SonarJS rules:
  - `sonarjs/cognitive-complexity: ["warn", 15]`
  - `sonarjs/max-switch-cases: ["warn", 30]`
  - `sonarjs/no-small-switch: "warn"`
- [ ] Configure magic number rules:
  - `no-magic-numbers: ["warn", { ignore: [0, 1, -1], ignoreArrayIndexes: true, ignoreDefaultValues: true, detectObjects: false }]`
- [ ] Test ESLint configuration

### SonarQube Configuration (If available)

- [ ] Configure SonarQube code smell rules
- [ ] Set thresholds for:
  - Method size
  - Class size
  - Nesting depth
  - Complexity
- [ ] Configure magic number detection
- [ ] Test SonarQube analysis

### Running Code Smell Detection

- [ ] Run ESLint with code smell rules on entire codebase
- [ ] Run SonarQube analysis (if available)
- [ ] Generate code smell report (JSON, HTML, or console output)
- [ ] Identify all long methods (>50 lines):
  - File locations and line numbers
  - Method names
  - Line counts
- [ ] Identify all large classes/files (>500 lines):
  - File locations
  - Line counts
  - Class names
- [ ] Identify all deep nesting (>4 levels):
  - File locations and line numbers
  - Nesting depth
  - Function/method names
- [ ] Identify all magic numbers:
  - File locations and line numbers
  - Numeric values
  - Context of usage
- [ ] Identify code smell patterns:
  - God classes (classes with too many responsibilities)
  - Feature envy (methods accessing other objects' data excessively)
  - Long parameter lists (>5 parameters)
  - Data clumps (groups of data that always appear together)
  - Primitive obsession (overuse of primitives instead of objects)
- [ ] Calculate code quality metrics:
  - Average method length
  - Average class/file size
  - Average nesting depth
  - Average cyclomatic complexity
  - Total magic numbers found

### Analysis and Documentation

- [ ] Review code smell findings and categorize:
  - Long methods
  - Large classes/files
  - Deep nesting
  - Magic numbers
  - Code smell patterns
- [ ] Document all significant code smells:
  - File locations and line numbers
  - Type of code smell
  - Severity (critical, high, medium, low)
  - Impact on maintainability
  - Suggested refactoring approach
- [ ] Create prioritized list of code smell issues:
  - Critical: Methods > 100 lines, classes > 1000 lines
  - High: Methods 50-100 lines, classes 500-1000 lines, nesting > 5 levels
  - Medium: Methods 30-50 lines, classes 300-500 lines, nesting 4-5 levels
  - Low: Minor code smells, magic numbers
- [ ] Document code smell baseline metrics:
  - Total long methods found
  - Total large classes/files found
  - Total deep nesting instances found
  - Total magic numbers found
  - Most problematic files (top 10)
  - Average code quality metrics
- [ ] Create code smell report document (markdown or HTML)
- [ ] Identify false positives (code that appears smelly but is acceptable):
  - Test files (may have longer methods)
  - Configuration files (may have many constants)
  - Framework-specific patterns

### Refactoring Plan

- [ ] Create refactoring plan prioritizing:
  - Critical code smells (long methods, large classes)
  - High-impact refactorings (deep nesting, complexity)
  - Medium-impact improvements (magic numbers, code smell patterns)
- [ ] Document refactoring strategy for each category
- [ ] Identify dependencies between code smells
- [ ] Plan refactoring order to avoid breaking changes
- [ ] Document testing requirements after refactoring

### Integration

- [ ] Integrate code smell checks into CI/CD pipeline (if applicable)
- [ ] Add code smell detection to pre-commit hooks (optional)
- [ ] Configure code smell gates (warn/fail build if smells exceed threshold)
- [ ] Set up automated code smell reporting
- [ ] Document how to run code smell detection locally

### Review and Validation

- [ ] Verify code smell detection runs successfully
- [ ] Verify reports are generated correctly
- [ ] Review code smell findings for accuracy
- [ ] Validate that all significant code smells are identified
- [ ] Ensure code smell metrics align with code review findings
- [ ] Test CI/CD integration (if configured)
- [ ] Verify ignore patterns work correctly
- [ ] Verify false positives are properly handled

## Configuration Example (ESLint plugins)

Update `.eslintrc.json`:

```json
{
  "plugins": ["@typescript-eslint", "prettier", "sonarjs", "no-magic-numbers"],
  "rules": {
    "complexity": ["warn", 15],
    "max-depth": ["warn", 4],
    "max-lines-per-function": ["warn", { "max": 50, "skipBlankLines": true, "skipComments": true }],
    "max-params": ["warn", 5],
    "sonarjs/cognitive-complexity": ["warn", 15],
    "sonarjs/max-switch-cases": ["warn", 30],
    "sonarjs/no-small-switch": "warn",
    "no-magic-numbers": [
      "warn",
      {
        "ignore": [0, 1, -1],
        "ignoreArrayIndexes": true,
        "ignoreDefaultValues": true,
        "detectObjects": false
      }
    ]
  }
}
```

## Configuration Example (package.json scripts)

Add code smell detection scripts:

```json
{
  "scripts": {
    "smells": "eslint src --ext .ts",
    "smells:report": "eslint src --ext .ts --format json --output-file reports/code-smells.json",
    "smells:fix": "eslint src --ext .ts --fix"
  }
}
```

## Configuration Example (SonarQube)

If using SonarQube, configure in `sonar-project.properties`:

```properties
sonar.javascript.lcov.reportPaths=coverage/lcov.info
sonar.javascript.file.suffixes=.ts,.js
sonar.typescript.lcov.reportPaths=coverage/lcov.info
sonar.typescript.file.suffixes=.ts
```

## Notes

- This task is part of Phase 4: Code Quality Audit
- Section: 1. Automated Code Smell Detection
- Focus on identifying and fixing code quality issues
- Document all findings and improvements
- Code smell detection should complement, not replace, code reviews
- Start with reasonable thresholds and adjust based on baseline results
- Some code smells may be acceptable in specific contexts (e.g., test files, configuration)
- Focus on code smells that impact maintainability and readability
- Integration with SonarQube (if set up in PHASE4-003) provides the most comprehensive analysis
- Consider both structural smells (size, complexity) and design smells (patterns, anti-patterns)
- Magic numbers should be replaced with named constants for better readability
- Long methods should be broken down into smaller, focused methods
- Large classes should be split into smaller, cohesive classes
- Deep nesting should be refactored using early returns, guard clauses, or extraction
- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE4-006
- Next: PHASE4-008

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
