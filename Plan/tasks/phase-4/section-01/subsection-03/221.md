# PHASE4-003: Set up SonarQube or similar code quality tool

**Section**: 1. Automated Code Smell Detection
**Subsection**: 1.3
**Task ID**: PHASE4-003

## Description

Set up SonarQube or a similar comprehensive code quality analysis tool to perform deep code quality analysis, detect code smells, measure technical debt, and track code quality metrics over time. This tool will complement the existing ESLint and Prettier setup by providing advanced static analysis, complexity metrics, code duplication detection, security vulnerability scanning, and maintainability ratings.

## Current State

The project currently has:

- **ESLint** configured with TypeScript rules (PHASE4-001)
- **Prettier** configured for code formatting (PHASE4-002)
- **Jest** for testing with coverage reporting (generates `coverage/lcov.info`)
- Basic linting and formatting scripts in package.json
- `.gitignore` file excluding `node_modules/`, `dist/`, `coverage/`, and other build artifacts
- Test directory structure: `tests/unit/`, `tests/integration/`, `tests/e2e/`
- **Note**: No CI/CD pipeline configuration found (no GitHub Actions workflows in `.github/workflows/`)

**Missing**: A comprehensive code quality analysis tool that provides:

- Advanced static code analysis beyond ESLint
- Code complexity metrics (cyclomatic complexity, cognitive complexity)
- Code duplication detection
- Security vulnerability scanning
- Technical debt measurement
- Code quality ratings and trends
- Integration with CI/CD pipeline

## Tool Options

Consider the following options:

1. **SonarQube** (Recommended)
   - Comprehensive static analysis platform
   - Supports TypeScript/JavaScript
   - Provides code smells, bugs, vulnerabilities, security hotspots
   - Technical debt calculation
   - Quality gates and project badges
   - Can be self-hosted or cloud (SonarCloud)
   - Free tier available for open source projects

2. **SonarCloud**
   - Cloud-hosted version of SonarQube
   - No infrastructure setup required
   - Free for open source projects
   - Easy GitHub/GitLab integration

3. **CodeClimate**
   - Cloud-based code quality platform
   - Provides maintainability ratings
   - Integrates with GitHub
   - Free tier available

4. **CodeQL** (GitHub Advanced Security)
   - Security-focused analysis
   - Free for public repositories
   - Good for vulnerability detection

## Checklist

### Tool Selection and Setup

- [ ] Research and compare code quality tool options (SonarQube, SonarCloud, CodeClimate, etc.)
- [ ] Choose appropriate tool based on project needs, budget, and infrastructure
- [ ] Install tool (self-hosted) or set up cloud account (SonarCloud/CodeClimate)
- [ ] Install SonarQube scanner CLI tool (if using SonarQube/SonarCloud)
- [ ] Add scanner as dev dependency or install globally

### Project Configuration

- [ ] Create project in chosen tool platform
- [ ] Generate authentication token (if required)
- [ ] Create `sonar-project.properties` file (if using SonarQube/SonarCloud)
- [ ] Configure project key and name
- [ ] Set source directories (`src/`)
- [ ] Set test directories (`tests/` - includes `tests/unit/`, `tests/integration/`, `tests/e2e/`)
- [ ] Configure exclusions (node_modules, dist, coverage, etc.) - verify alignment with `.gitignore` patterns
- [ ] Set TypeScript/JavaScript language settings
- [ ] Verify coverage report path (`coverage/lcov.info`) matches Jest configuration

### Quality Gates and Rules

- [ ] Review default quality gates
- [ ] Configure quality gate thresholds:
  - Code coverage percentage
  - Duplicated lines threshold
  - Maintainability rating
  - Reliability rating (bugs)
  - Security rating (vulnerabilities)
- [ ] Customize rules if needed (disable false positives, adjust severity)
- [ ] Set up quality gate conditions for CI/CD

### Integration

- [ ] Add analysis script to package.json (e.g., `"sonar": "sonar-scanner"`)
- [ ] Configure environment variables for authentication
- [ ] Set up CI/CD integration (GitHub Actions, GitLab CI, etc.)
  - **Note**: No CI/CD configuration currently exists - this step will require creating CI/CD workflows
  - If using GitHub Actions, create `.github/workflows/` directory and workflow files
- [ ] Configure analysis to run on pull requests
- [ ] Set up quality gate enforcement in CI/CD pipeline
- [ ] Add SonarQube/SonarCloud badge to README (if available and README exists)

### Initial Analysis

- [ ] Run initial code analysis
- [ ] Review analysis results and metrics
- [ ] Identify baseline code quality metrics:
  - Code coverage percentage
  - Number of code smells
  - Technical debt estimate
  - Security vulnerabilities
  - Code duplication percentage
- [ ] Document baseline metrics

### Documentation

- [ ] Document tool setup process
- [ ] Document configuration choices and rationale
- [ ] Create guide for running analysis locally
- [ ] Document CI/CD integration steps
- [ ] Document how to interpret quality metrics
- [ ] Add tool usage instructions to project README or docs
- [ ] Document quality gate thresholds and their meaning

### Review and Validation

- [ ] Verify analysis runs successfully
- [ ] Verify results are accessible via web interface
- [ ] Test CI/CD integration (if CI/CD workflows are created)
- [ ] Verify quality gates work correctly
- [ ] Review and address any configuration issues
- [ ] Ensure tool complements existing ESLint/Prettier setup without conflicts
- [ ] Verify that exclusions match `.gitignore` patterns and project structure
- [ ] Confirm coverage report integration works correctly (coverage/lcov.info is found and parsed)

## Configuration Example (SonarQube/SonarCloud)

If using SonarQube or SonarCloud, create `sonar-project.properties`:

```properties
sonar.projectKey=telegram-receiver
sonar.projectName=Telegram Receiver
sonar.sources=src
sonar.tests=tests
sonar.exclusions=**/node_modules/**,**/dist/**,**/coverage/**,**/*.spec.ts,**/*.test.ts
sonar.test.exclusions=**/node_modules/**,**/dist/**
sonar.javascript.lcov.reportPaths=coverage/lcov.info
sonar.sourceEncoding=UTF-8
sonar.typescript.tsconfigPath=tsconfig.json
```

**Notes on Configuration**:

- Coverage report path (`coverage/lcov.info`) matches Jest configuration in `jest.config.ts`
- Exclusions align with `.gitignore` patterns (node_modules, dist, coverage)
- Test exclusions include both `.spec.ts` and `.test.ts` patterns (Jest supports both)
- TypeScript config path references the root `tsconfig.json` file

## Notes

- This task is part of Phase 4: Code Quality Audit
- Section: 1. Automated Code Smell Detection
- Focus on identifying and fixing code quality issues
- Document all findings and improvements
- The chosen tool should complement, not replace, ESLint and Prettier
- Consider free/open-source options first (SonarCloud free tier, CodeQL)
- Quality gates should be set to reasonable thresholds initially, then tightened over time
- Integration with CI/CD is important for continuous quality monitoring
- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE4-002
- Next: PHASE4-004

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
