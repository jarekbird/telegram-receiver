# PHASE4-003: Set up SonarQube or similar code quality tool

**Section**: 1. Automated Code Smell Detection
**Subsection**: 1.3
**Task ID**: PHASE4-003

## Description

Set up SonarQube or a similar comprehensive code quality analysis tool to perform deep code quality analysis, detect code smells, measure technical debt, and track code quality metrics over time. This tool will complement the existing ESLint and Prettier setup by providing advanced static analysis, complexity metrics, code duplication detection, security vulnerability scanning, and maintainability ratings.

## Current State

The project currently has:

- **ESLint** configured with TypeScript rules (PHASE4-001)
- **Prettier** configured for code formatting (PHASE4-002)
- **Jest** for testing with coverage reporting (generates `coverage/lcov.info`)
- Basic linting and formatting scripts in package.json
- `.gitignore` file excluding `node_modules/`, `dist/`, `coverage/`, and other build artifacts
- Test directory structure: `tests/unit/`, `tests/integration/`, `tests/e2e/`
- **Note**: No CI/CD pipeline configuration found (no GitHub Actions workflows in `.github/workflows/`)

**Missing**: A comprehensive code quality analysis tool that provides:

- Advanced static code analysis beyond ESLint
- Code complexity metrics (cyclomatic complexity, cognitive complexity)
- Code duplication detection
- Security vulnerability scanning
- Technical debt measurement
- Code quality ratings and trends
- Integration with CI/CD pipeline

## Tool Options

Consider the following options:

1. **SonarQube** (Recommended)
   - Comprehensive static analysis platform
   - Supports TypeScript/JavaScript
   - Provides code smells, bugs, vulnerabilities, security hotspots
   - Technical debt calculation
   - Quality gates and project badges
   - Can be self-hosted or cloud (SonarCloud)
   - Free tier available for open source projects

2. **SonarCloud**
   - Cloud-hosted version of SonarQube
   - No infrastructure setup required
   - Free for open source projects
   - Easy GitHub/GitLab integration

3. **CodeClimate**
   - Cloud-based code quality platform
   - Provides maintainability ratings
   - Integrates with GitHub
   - Free tier available

4. **CodeQL** (GitHub Advanced Security)
   - Security-focused analysis
   - Free for public repositories
   - Good for vulnerability detection

## Checklist

### Tool Selection and Setup

- [ ] Research and compare code quality tool options (SonarQube, SonarCloud, CodeClimate, etc.)
- [ ] Choose appropriate tool based on project needs, budget, and infrastructure
- [ ] Install tool (self-hosted) or set up cloud account (SonarCloud/CodeClimate)
- [ ] Install SonarQube scanner CLI tool (if using SonarQube/SonarCloud)
- [ ] Add scanner as dev dependency or install globally

### Project Configuration

- [ ] Create project in chosen tool platform
- [ ] Generate authentication token (if required)
- [ ] Create `sonar-project.properties` file (if using SonarQube/SonarCloud)
- [ ] Configure project key and name
- [ ] Set source directories (`src/`)
- [ ] Set test directories (`tests/` - includes `tests/unit/`, `tests/integration/`, `tests/e2e/`)
- [ ] Configure exclusions (node_modules, dist, coverage, etc.) - verify alignment with `.gitignore` patterns
- [ ] Set TypeScript/JavaScript language settings
- [ ] Verify coverage report path (`coverage/lcov.info`) matches Jest configuration

### Quality Gates and Rules

- [ ] Review default quality gates
- [ ] Configure quality gate thresholds:
  - Code coverage percentage
  - Duplicated lines threshold
  - Maintainability rating
  - Reliability rating (bugs)
  - Security rating (vulnerabilities)
- [ ] Customize rules if needed (disable false positives, adjust severity)
- [ ] Set up quality gate conditions for CI/CD

### Integration

- [ ] Add analysis script to package.json (e.g., `"sonar": "sonar-scanner"`)
- [ ] Configure environment variables for authentication
- [ ] Set up CI/CD integration (GitHub Actions, GitLab CI, etc.)
  - **Note**: No CI/CD configuration currently exists - this step will require creating CI/CD workflows
  - If using GitHub Actions, create `.github/workflows/` directory and workflow files
- [ ] Configure analysis to run on pull requests
- [ ] Set up quality gate enforcement in CI/CD pipeline
- [ ] Add SonarQube/SonarCloud badge to README (if available and README exists)

### Initial Analysis

- [ ] Run initial code analysis
- [ ] Review analysis results and metrics
- [ ] Identify baseline code quality metrics:
  - Code coverage percentage
  - Number of code smells
  - Technical debt estimate
  - Security vulnerabilities
  - Code duplication percentage
- [ ] Document baseline metrics

### Documentation

- [ ] Document tool setup process
- [ ] Document configuration choices and rationale
- [ ] Create guide for running analysis locally
- [ ] Document CI/CD integration steps
- [ ] Document how to interpret quality metrics
- [ ] Add tool usage instructions to project README or docs
- [ ] Document quality gate thresholds and their meaning

### Review and Validation

- [ ] Verify analysis runs successfully
- [ ] Verify results are accessible via web interface
- [ ] Test CI/CD integration (if CI/CD workflows are created)
- [ ] Verify quality gates work correctly
- [ ] Review and address any configuration issues
- [ ] Ensure tool complements existing ESLint/Prettier setup without conflicts
- [ ] Verify that exclusions match `.gitignore` patterns and project structure
- [ ] Confirm coverage report integration works correctly (coverage/lcov.info is found and parsed)

## Configuration Example (SonarQube/SonarCloud)

If using SonarQube or SonarCloud, create `sonar-project.properties`:

```properties
sonar.projectKey=telegram-receiver
sonar.projectName=Telegram Receiver
sonar.sources=src
sonar.tests=tests
sonar.exclusions=**/node_modules/**,**/dist/**,**/coverage/**,**/*.spec.ts,**/*.test.ts
sonar.test.exclusions=**/node_modules/**,**/dist/**
sonar.javascript.lcov.reportPaths=coverage/lcov.info
sonar.sourceEncoding=UTF-8
sonar.typescript.tsconfigPath=tsconfig.json
```

**Notes on Configuration**:

- Coverage report path (`coverage/lcov.info`) matches Jest configuration in `jest.config.ts`
- Exclusions align with `.gitignore` patterns (node_modules, dist, coverage)
- Test exclusions include both `.spec.ts` and `.test.ts` patterns (Jest supports both)
- TypeScript config path references the root `tsconfig.json` file

## Notes

- This task is part of Phase 4: Code Quality Audit
- Section: 1. Automated Code Smell Detection
- Focus on identifying and fixing code quality issues
- Document all findings and improvements
- The chosen tool should complement, not replace, ESLint and Prettier
- Consider free/open-source options first (SonarCloud free tier, CodeQL)
- Quality gates should be set to reasonable thresholds initially, then tightened over time
- Integration with CI/CD is important for continuous quality monitoring
- Task can be completed independently by a single agent

## Related Tasks

- Previous: PHASE4-002
- Next: PHASE4-004

## Definition of Done

This document defines the criteria for task completion. The review agent uses these definitions to evaluate whether a task has been completed successfully.

### 1. CODE/FILE WRITING TASKS

**Description**: Tasks that involve writing, creating, modifying, or implementing SOURCE CODE FILES that need to be committed to git.

**Definition of Done**: "A Pull Request was created OR code was pushed to origin with the task complete"

**Examples**:
- Creating new source code files
- Modifying existing source code files
- Implementing features, functions, classes, modules
- Writing tests, specs
- Refactoring code
- Fixing bugs in source code

### 2. SYSTEM/ENVIRONMENT OPERATION TASKS

**Description**: Tasks involving installing dependencies, running builds, installing packages, running migrations, executing install scripts, etc.

**Definition of Done**: "The required operation must complete successfully with no errors, and the expected artifacts must be created. If any part of the operation fails, the task is NOT complete."

**Important Notes**:
- Installing dependencies requires packages to actually be installed successfully
- Updating package.json is NOT enough
- If the output mentions environmental issues, errors, warnings, or failed operations, the task is NOT complete

**Examples**:
- Installing npm packages, pip packages, gem dependencies
- Running database migrations
- Building/compiling projects
- Setting up development environments
- Running install scripts

