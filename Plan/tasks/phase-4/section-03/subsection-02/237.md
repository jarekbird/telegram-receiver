# PHASE4-019: Simplify complex logic

**Section**: 3. Refactoring
**Subsection**: 3.2
**Task ID**: PHASE4-019

## Description

Simplify complex logic to improve code quality and maintainability. This task focuses on systematically addressing complex logic identified through complexity analysis (PHASE4-004), complex business logic review (PHASE4-010), automated code quality reports (PHASE4-009), and manual code review findings (PHASE4-017). The goal is to improve code readability, maintainability, and reduce cognitive complexity by breaking down complex functions, simplifying conditional logic, extracting helper functions, and improving algorithm clarity.

## Current State

**Important**: This task should be executed **after Phase 2 conversion** when actual business logic has been implemented. If the application is still in early development with minimal source code, this task should focus on preparation and setup rather than simplification.

Complex logic may have been identified through:

- **PHASE4-004**: Complexity analysis (cyclomatic complexity, cognitive complexity metrics) - **May not be completed yet**
- **PHASE4-010**: Complex business logic review (`docs/manual-code-review.md`) - **Completed**
- **PHASE4-009**: Automated code quality report (`docs/code-quality-report.md`) - **May not exist yet**
- **PHASE4-017**: Manual code review report (`docs/manual-code-review.md`) - **Completed**

**Manual Code Review Findings** (from PHASE4-017):

- PHASE4-010 found **no complex business logic** at the time of review (early development stage)
- Application is in early development - complex logic may emerge after Phase 2 conversion
- Test utilities reviewed: Low complexity, well-structured
- **Current state**: `src/index.ts` is empty, no business logic implemented yet

**Complexity Analysis Findings** (if PHASE4-004 is completed):

- Check complexity analysis reports for functions with:
  - Cyclomatic complexity > 10 (high complexity)
  - Cyclomatic complexity > 20 (critical complexity)
  - Cognitive complexity > 15 (high cognitive load)
- **Note**: ESLint complexity rules are currently **NOT enabled** in `.eslintrc.json`. If complexity analysis hasn't been run, enable ESLint complexity rules first (see PHASE4-004)
- Check ESLint complexity rule violations: `npm run lint` (will only work if complexity rules are enabled)
- Review files with highest average complexity scores

**Automated Findings** (if PHASE4-009 is completed):

- Check `docs/code-quality-report.md` for consolidated complexity findings - **File may not exist yet**
- Review SonarQube reports (if configured) for complexity metrics

**If No Complex Logic Exists** (Current State):

- If no complex logic has been identified (e.g., early development stage, no business logic implemented):
  - Complete preparation steps (enable complexity analysis, set up tooling)
  - Document that no complex logic exists at this time
  - Mark task as ready for execution after Phase 2 conversion
  - Set up complexity monitoring for future code

**Complex Logic Indicators**:

1. **High Cyclomatic Complexity**: Functions with many decision points (>10)
2. **High Cognitive Complexity**: Functions that are difficult to understand (>15)
3. **Deep Nesting**: Nested conditionals exceeding 4 levels
4. **Long Functions**: Functions exceeding 50 lines with complex logic
5. **Complex Conditionals**: Multiple boolean conditions, nested ternaries, complex switch statements
6. **Complex Algorithms**: Algorithms with multiple steps, state management, or intricate logic flows
7. **God Functions**: Functions that do too many things

## Checklist

### Preparation and Prioritization

- [ ] **If no complex logic exists yet** (early development stage):
  - [ ] Document current state: no complex logic identified
  - [ ] Enable ESLint complexity rules if PHASE4-004 hasn't been completed (add `complexity` rule to `.eslintrc.json`)
  - [ ] Set up complexity monitoring for future code
  - [ ] Mark task as ready for execution after Phase 2 conversion
  - [ ] Skip to Documentation section to document current state
- [ ] Review complexity analysis results from PHASE4-004 (if available)
- [ ] Review complex business logic findings from PHASE4-010 (`docs/manual-code-review.md`)
- [ ] Review automated code quality report (`docs/code-quality-report.md`) if PHASE4-009 is completed (file may not exist yet)
- [ ] Review manual code review findings (`docs/manual-code-review.md`)
- [ ] **If ESLint complexity rules are not enabled**:
  - [ ] Enable complexity rules in `.eslintrc.json` (see PHASE4-004 for configuration)
  - [ ] Add `complexity: ["warn", 10]` and related rules (`max-depth`, `max-lines-per-function`, `max-params`)
- [ ] Run ESLint complexity checks: `npm run lint` (check for complexity rule violations - only works if rules are enabled)
- [ ] Review SonarQube reports (if available) for complexity metrics
- [ ] **If complex logic exists**, compile comprehensive list of all identified complex logic with:
  - File locations and line numbers
  - Complexity metrics (cyclomatic, cognitive)
  - Function/method names
  - Description of complexity (nested conditionals, long functions, complex algorithms)
  - Impact on maintainability and readability
  - Estimated simplification effort
- [ ] **If complex logic exists**, prioritize complex logic simplification by:
  - Critical: Cyclomatic complexity > 20, cognitive complexity > 25
  - High: Cyclomatic complexity 11-20, cognitive complexity 16-25, deeply nested logic (>5 levels)
  - Medium: Cyclomatic complexity 6-10, cognitive complexity 10-15, moderate nesting (3-4 levels)
  - Low: Minor complexity improvements, readability enhancements
- [ ] **If complex logic exists**, create simplification plan with dependencies and order of execution
- [ ] **If complex logic exists**, ensure test coverage exists before simplification (add tests if needed)
- [ ] **If no complex logic exists**, document this finding and note that task should be revisited after Phase 2 conversion

### Identifying Complex Logic

- [ ] Review all functions with cyclomatic complexity > 10
- [ ] Review all functions with cognitive complexity > 15
- [ ] Identify functions with deep nesting (>4 levels)
- [ ] Identify functions with complex conditional logic:
  - Multiple boolean conditions in single if statement
  - Nested ternary operators
  - Complex switch statements with nested logic
  - Multiple levels of if-else chains
- [ ] Identify functions with complex algorithms:
  - Multi-step algorithms with state management
  - Algorithms with intricate control flow
  - Algorithms with multiple responsibilities
- [ ] Identify functions that are difficult to understand:
  - Functions requiring extensive comments to explain
  - Functions with unclear variable names
  - Functions with magic numbers or unclear constants
- [ ] Document each identified complex logic section with:
  - Location (file, function, line numbers)
  - Complexity type and metrics
  - Why it's complex
  - Simplification opportunities

### Breaking Down Complex Functions

- [ ] For each complex function identified:
  - [ ] Analyze function responsibilities and identify extraction opportunities
  - [ ] Identify logical blocks that can be extracted
  - [ ] Extract logical blocks into well-named helper functions
  - [ ] Ensure extracted functions have single responsibility
  - [ ] Maintain function behavior (no functional changes)
  - [ ] Update function documentation (JSDoc)
- [ ] For functions with multiple responsibilities:
  - [ ] Split into multiple focused functions
  - [ ] Use composition to combine simpler functions
  - [ ] Ensure each function has clear, single purpose
- [ ] Run tests after each function simplification
- [ ] Verify no functionality was broken

### Extracting Helper Functions

- [ ] Identify repeated logic patterns that can be extracted
- [ ] Extract complex calculations into named functions
- [ ] Extract validation logic into separate functions
- [ ] Extract data transformation logic into separate functions
- [ ] Extract error handling logic into separate functions
- [ ] Ensure extracted helper functions:
  - Have descriptive, purpose-driven names
  - Have single responsibility
  - Are reusable where appropriate
  - Have proper JSDoc documentation
  - Are properly typed (TypeScript)
- [ ] Consider creating utility modules for common helper functions
- [ ] Run tests after each extraction
- [ ] Verify behavior is unchanged

### Simplifying Conditional Logic

- [ ] For complex boolean conditions:
  - [ ] Extract complex conditions into well-named boolean variables
  - [ ] Break down multiple conditions into separate checks
  - [ ] Use early returns/guard clauses to reduce nesting
  - [ ] Consider using lookup tables or maps for complex conditionals
- [ ] For nested conditionals:
  - [ ] Use early returns to flatten nesting
  - [ ] Extract nested logic into separate functions
  - [ ] Use guard clauses for validation checks
  - [ ] Consider using strategy pattern for complex conditionals
- [ ] For complex switch statements:
  - [ ] Extract switch logic into separate functions
  - [ ] Consider using object maps or lookup tables
  - [ ] Simplify case logic
- [ ] For ternary operators:
  - [ ] Replace nested ternaries with if-else statements
  - [ ] Extract complex ternaries into separate functions
  - [ ] Use ternary only for simple, clear conditions
- [ ] Run tests after each conditional simplification
- [ ] Verify logic correctness

### Improving Algorithm Clarity

- [ ] For complex algorithms:
  - [ ] Break down algorithm into clear steps
  - [ ] Extract each step into well-named functions
  - [ ] Add comments explaining algorithm approach (not implementation details)
  - [ ] Use descriptive variable names that explain purpose
  - [ ] Replace magic numbers with named constants
  - [ ] Simplify control flow where possible
- [ ] For state management in algorithms:
  - [ ] Extract state into well-named variables
  - [ ] Use clear state transitions
  - [ ] Consider using state machine pattern if appropriate
- [ ] For iterative algorithms:
  - [ ] Use descriptive loop variable names
  - [ ] Extract loop body logic into functions if complex
  - [ ] Use array methods (map, filter, reduce) where appropriate for clarity
- [ ] Run tests after each algorithm improvement
- [ ] Verify algorithm correctness

### Adding Comments for Complex Parts

- [ ] Identify parts that remain complex after simplification attempts
- [ ] Add JSDoc comments explaining:
  - Why the code is complex (business requirements, constraints)
  - What the code does (high-level approach)
  - Important edge cases or gotchas
- [ ] Add inline comments for:
  - Non-obvious logic decisions
  - Complex calculations that can't be simplified further
  - Workarounds or temporary solutions
- [ ] Ensure comments explain "why" not "what"
- [ ] Update comments if code changes
- [ ] Consider if commented complexity can be further simplified

### Testing Simplified Logic

- [ ] Run full test suite after each simplification: `npm test`
- [ ] Run type checking: `npm run type-check`
- [ ] Run linting: `npm run lint`
- [ ] Verify test coverage hasn't decreased: `npm run test:coverage`
- [ ] Add tests for edge cases if they weren't covered before
- [ ] **DO NOT manually test by running the server** - use automated tests instead
- [ ] Ensure all affected functionality is covered by automated tests (unit, integration, or e2e tests)
- [ ] Verify complexity metrics improved (re-run complexity analysis)
- [ ] Ensure no new complexity was introduced

### Documentation

- [ ] Document each simplification change:
  - [ ] What was simplified (file, function name, complexity type)
  - [ ] Why it was simplified (complexity metrics, maintainability impact)
  - [ ] How it was simplified (extraction, refactoring technique used)
  - [ ] Before/after complexity metrics (if available)
  - [ ] Any breaking changes (if applicable)
- [ ] Update code comments and JSDoc as needed
- [ ] Create simplification summary document or update code quality report
- [ ] Update architecture documentation if structural changes were made
- [ ] Document simplification patterns used for future reference

### Verification

- [ ] Re-run complexity analysis to verify improvements:
  - [ ] ESLint complexity rules: `npm run lint`
  - [ ] Complexity analysis tool (if PHASE4-004 configured)
  - [ ] SonarQube analysis (if available)
- [ ] Compare before/after metrics:
  - [ ] Number of functions with complexity > 10 (should decrease)
  - [ ] Number of functions with complexity > 20 (should decrease)
  - [ ] Average cyclomatic complexity (should decrease)
  - [ ] Average cognitive complexity (should decrease)
  - [ ] Maximum nesting depth (should decrease)
- [ ] Verify code quality score improved (if metrics available)
- [ ] Ensure no regressions were introduced
- [ ] Verify code readability improved (manual review)

## Notes

- This task is part of Phase 4: Code Quality Audit
- Section: 3. Refactoring
- **Execution Timing**: This task should be executed **after Phase 2 conversion** when actual business logic has been implemented. If the application is still in early development, focus on preparation and setup.
- Focus on systematically addressing complex logic identified in previous tasks
- Document all findings and improvements
- **Important**: Always run tests after each simplification to ensure no functionality is broken
- **Important**: Simplification should improve code quality without changing behavior
- **Important**: If complexity analysis (PHASE4-004) is not available, work with manual review findings (PHASE4-017) and enable ESLint complexity rules
- **Important**: If no complex logic exists (current state), document this and set up complexity monitoring for future code
- **Important**: ESLint complexity rules are currently NOT enabled - enable them if complexity analysis hasn't been run (see PHASE4-004)
- Start with high-impact, low-risk simplifications
- Consider dependencies between complex logic sections (some may need to be simplified together)
- Not all complexity is bad - some algorithms are inherently complex. Focus on reducing unnecessary complexity and improving clarity
- Use descriptive names to reduce cognitive load - a well-named function is better than a comment
- Extract helper functions even if they're only used once if it improves readability
- Early returns and guard clauses are powerful tools for reducing nesting
- Complex conditionals can often be simplified using lookup tables, maps, or strategy patterns
- Task can be completed independently by a single agent, but may require multiple iterations if many complex logic sections are identified
- **Current State**: Application is in early development - `src/index.ts` is empty, no business logic implemented. Manual code review found no complex business logic. Task should be revisited after Phase 2 conversion.

## Related Tasks

- Previous: PHASE4-018
- Next: PHASE4-020

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
