# PHASE4-012: Verify consistent error messages

**Section**: 2. Manual Code Review
**Subsection**: 2.3
**Task ID**: PHASE4-012

## Description

Verify consistent error messages across the codebase to improve code quality and maintainability. Review error message formats, clarity, user-friendliness, and consistency. Document error message standards and create a style guide for future development.

## Checklist

- [ ] Review error messages across codebase
- [ ] Check for consistent error message format
- [ ] Review error message clarity
- [ ] Check for user-friendly error messages
- [ ] Review error message localization (if applicable)
- [ ] Identify inconsistent error messages
- [ ] Document error message standards
- [ ] Create error message style guide

## Notes

- This task is part of Phase 4: Code Quality Audit
- Section: 2. Manual Code Review
- Focus on identifying and fixing code quality issues
- Document all findings and improvements

- Task can be completed independently by a single agent

## Evaluation Results

### Current State Assessment

**Date**: 2025-01-17

**Status**: Application is in early development stage with minimal source code implemented. Error messages exist primarily in test utilities and fixtures. Main application code (services, controllers, middleware) has not been implemented yet, so comprehensive error message review will be applicable once Phase 2 conversion tasks are completed.

### Findings

#### 1. Error Messages Review Across Codebase

**Test Utilities** (`tests/helpers/testUtils.ts`):

- ✅ **Error Message Found**: `'Expected promise to reject, but it resolved'`
- ✅ **Quality**: Clear and descriptive - accurately describes the test failure condition
- ✅ **Format**: Consistent - uses standard Error constructor with string message
- ✅ **Context**: Appropriate for test utility - technical but clear

**Test Fixtures** (`tests/fixtures/apiResponses.ts`):

- ✅ **Error Messages Found**:
  - `'Task failed'` (error field)
  - `'An error occurred while processing the task'` (message field)
- ⚠️ **Consistency Issue**: Two different error message fields (`error` and `message`) in the same response object
- ⚠️ **Clarity**: Generic messages - appropriate for fixtures but should be more specific in actual implementation
- **Note**: These are mock responses, not actual application error messages

**Source Code** (`src/`):

- ⚠️ **Status**: No source code files exist yet (only empty `index.ts`)
- **Note**: Error message review will be applicable once Phase 2 conversion tasks are completed

**Architecture Documentation** (`docs/architecture.md`):

- ✅ **Error Handling Strategy**: Well-documented error handling approach
- ✅ **Error Response Format**: Defined standard format:
  ```typescript
  {
    ok: false,
    error: "Error message",
    details?: {} // Optional additional details
  }
  ```
- ✅ **Error Types**: Documented error categories:
  - Validation Errors
  - Authentication Errors
  - External API Errors
  - Network Errors
  - Business Logic Errors
- ✅ **Error Pattern**: Documented pattern for custom error classes and centralized error middleware

#### 2. Consistent Error Message Format Review

**Current State**:

- ⚠️ **Status**: Limited error messages exist (only in test utilities)
- ✅ **Test Utilities**: Consistent format using `throw new Error('message')`
- ✅ **Test Fixtures**: Fixed - now uses architecture-defined format `{ ok: false, error: "...", details?: {} }`

**Architecture Standard** (from `docs/architecture.md`):

- ✅ **Defined Format**: `{ ok: false, error: "Error message", details?: {} }`
- ✅ **Custom Error Classes**: Pattern documented for typed errors (e.g., `TelegramApiError`)
- ✅ **Error Middleware**: Centralized error handling approach documented

**Recommendation**:

- Follow the architecture-defined error response format
- Use custom error classes for type safety
- Ensure all API error responses follow the `{ ok: false, error: "...", details?: {} }` format

#### 3. Error Message Clarity Review

**Test Utilities**:

- ✅ **Clarity**: Excellent - `'Expected promise to reject, but it resolved'` is clear and actionable
- ✅ **Technical Level**: Appropriate for test utilities (developer-facing)

**Test Fixtures**:

- ⚠️ **Clarity**: Generic messages (`'Task failed'`, `'An error occurred while processing the task'`)
- **Note**: Acceptable for fixtures, but actual implementation should have more specific messages

**Architecture Guidance**:

- ✅ **Documented**: Error messages should not expose sensitive information (from security section)
- ✅ **Pattern**: Services throw typed errors with descriptive messages
- ✅ **Middleware**: Centralized error middleware handles uncaught errors with generic message

**Recommendations**:

- Error messages should be clear and actionable
- Include context where helpful (e.g., "Failed to send message to Telegram API: timeout after 5s")
- Avoid exposing sensitive information (API keys, tokens, internal paths)
- Use consistent terminology (e.g., "Failed to..." vs "Error while...")

#### 4. User-Friendly Error Messages Review

**Current State**:

- ⚠️ **Status**: No user-facing error messages exist yet
- **Note**: Application will have both:
  - **API Error Responses**: For HTTP API consumers (should be clear and structured)
  - **Telegram Messages**: For end users (should be user-friendly and non-technical)

**Architecture Guidance**:

- ✅ **Error Response Format**: Defined for API consumers
- ⚠️ **User-Facing Messages**: Not explicitly documented in architecture
- **Recommendation**: Define separate standards for:
  - API error responses (technical, structured)
  - Telegram user messages (user-friendly, non-technical)

**Recommendations**:

- **API Errors**: Technical but clear (e.g., "Invalid webhook secret token")
- **User Messages**: Friendly and actionable (e.g., "I couldn't process your request. Please try again.")
- Avoid technical jargon in user-facing messages
- Provide actionable guidance when possible

#### 5. Error Message Localization Review

**Current State**:

- ⚠️ **Status**: No localization implemented
- **Note**: All error messages are in English

**Architecture Documentation**:

- ⚠️ **Localization**: Not mentioned in architecture documentation
- **Recommendation**: Document localization strategy if multi-language support is planned

**Recommendations**:

- If localization is needed, use i18n library (e.g., `i18next`)
- Extract error messages to translation files
- Use message keys instead of hardcoded strings
- For now, English-only is acceptable for MVP

#### 6. Inconsistent Error Messages Identified

**Issues Found**:

1. **Test Fixtures Inconsistency** (`tests/fixtures/apiResponses.ts`) ✅ **FIXED**:
   - ~~Uses both `error` and `message` fields in error response~~ → Fixed
   - ✅ Now aligns with architecture-defined format: `{ ok: false, error: "...", details?: {} }`
   - ✅ Updated both success and error response formats to use `ok` field consistently

2. **Missing Error Message Standards**:
   - No documented error message style guide
   - No examples of good vs bad error messages
   - **Fix**: Create error message style guide (see below)

3. **Architecture vs Implementation Gap**:
   - Architecture defines error response format, but no implementation exists yet
   - **Fix**: Ensure Phase 2 conversion follows architecture standards

#### 7. Error Message Standards Documentation

**Current State**:

- ✅ **Architecture Documentation**: Error handling strategy documented
- ⚠️ **Style Guide**: No detailed error message style guide exists
- ⚠️ **Examples**: No examples of error message patterns

**Recommendations**:

- Create comprehensive error message style guide (see below)
- Document error message patterns for each error type
- Provide examples of good and bad error messages
- Include guidelines for user-facing vs API error messages

#### 8. Error Message Style Guide

**Recommended Error Message Style Guide**:

##### General Principles

1. **Be Clear and Specific**
   - ✅ Good: `"Failed to send message to Telegram API: timeout after 5 seconds"`
   - ❌ Bad: `"Error occurred"`

2. **Use Consistent Format**
   - ✅ Good: `"Failed to [action]: [reason]"`
   - ❌ Bad: Mixing formats like `"Error: ..."`, `"Failed: ..."`, `"... failed"`

3. **Include Context When Helpful**
   - ✅ Good: `"Invalid webhook secret token provided"`
   - ❌ Bad: `"Authentication failed"`

4. **Avoid Exposing Sensitive Information**
   - ✅ Good: `"Invalid authentication credentials"`
   - ❌ Bad: `"Invalid API key: sk-1234567890abcdef"`

5. **Use Appropriate Technical Level**
   - **API Errors**: Technical but clear (for developers)
   - **User Messages**: Friendly and non-technical (for end users)

##### Error Message Patterns

**API Error Responses** (HTTP API):

```typescript
// Format: { ok: false, error: "message", details?: {} }
{
  ok: false,
  error: "Failed to send message to Telegram API: timeout after 5 seconds",
  details: {
    endpoint: "/telegram/sendMessage",
    retryable: true
  }
}
```

**Custom Error Classes**:

```typescript
// Pattern: throw new [Type]Error('message', { context })
throw new TelegramApiError('Failed to send message', {
  statusCode: 500,
  endpoint: '/sendMessage',
});
```

**User-Facing Messages** (Telegram):

```typescript
// Format: Friendly, actionable, non-technical
"I couldn't send your message right now. Please try again in a moment.";
```

##### Error Message Categories

1. **Validation Errors**:
   - Pattern: `"Invalid [field]: [reason]"`
   - Example: `"Invalid webhook URL: must be HTTPS"`

2. **Authentication Errors**:
   - Pattern: `"Authentication failed: [reason]"`
   - Example: `"Authentication failed: invalid secret token"`

3. **External API Errors**:
   - Pattern: `"Failed to [action] via [service]: [reason]"`
   - Example: `"Failed to send message via Telegram API: rate limit exceeded"`

4. **Network Errors**:
   - Pattern: `"Network error: [reason]"`
   - Example: `"Network error: connection timeout after 5 seconds"`

5. **Business Logic Errors**:
   - Pattern: `"[Action] failed: [reason]"`
   - Example: `"Message processing failed: audio transcription service unavailable"`

##### Consistency Checklist

- [ ] All API error responses use `{ ok: false, error: "...", details?: {} }` format
- [ ] All error messages start with action verb (e.g., "Failed to...", "Invalid...")
- [ ] Error messages include context when helpful
- [ ] No sensitive information in error messages
- [ ] User-facing messages are friendly and non-technical
- [ ] API error messages are technical but clear
- [ ] Consistent terminology across all error messages

### Task Checklist Status

- [x] Review error messages across codebase - **Completed** - Reviewed test utilities and fixtures
- [x] Check for consistent error message format - **Completed** - Found inconsistencies in test fixtures
- [x] Review error message clarity - **Completed** - Test utilities are clear, fixtures are generic
- [x] Check for user-friendly error messages - **N/A** - No user-facing messages exist yet
- [x] Review error message localization - **N/A** - No localization implemented
- [x] Identify inconsistent error messages - **Completed** - Found fixture inconsistency
- [x] Document error message standards - **Completed** - Created style guide above
- [x] Create error message style guide - **Completed** - Style guide created above

### Recommendations

#### Immediate Actions

1. **Fix Test Fixture Inconsistency** (Priority: Low) ✅ **COMPLETED**
   - ✅ Updated `tests/fixtures/apiResponses.ts` to use architecture-defined format
   - ✅ Changed from `{ success: false, error: "...", message: "..." }` to `{ ok: false, error: "...", details?: {} }`
   - ✅ Fixed both success and error response formats to use `ok` field instead of `success`
   - **Note**: Fixture now aligns with architecture-defined error response format

#### Future Actions (After Phase 2 Conversion)

2. **Implement Error Message Standards** (Priority: High)
   - Ensure all API error responses follow `{ ok: false, error: "...", details?: {} }` format
   - Use custom error classes as documented in architecture
   - Implement centralized error middleware
   - Follow error message style guide patterns

3. **Create User-Facing Error Messages** (Priority: Medium)
   - Define standards for Telegram user messages
   - Ensure messages are friendly and non-technical
   - Provide actionable guidance when possible

4. **Error Message Validation** (Priority: Medium)
   - Add linting rules to enforce error message format
   - Create tests to verify error message consistency
   - Document error message patterns in code comments

5. **Error Message Documentation** (Priority: Low)
   - Document all error codes and messages in API documentation
   - Create error message reference guide
   - Include error message examples in developer documentation

### Conclusion

The current error message state is **minimal but acceptable** for the early development stage. Test utilities have clear error messages, test fixtures have been updated to align with the architecture-defined format, and the architecture documentation provides a solid foundation for error handling. A comprehensive error message style guide has been created to guide future development.

**Error Message Quality Score**: 7/10 (improved from 6/10)

- **Strengths**: Architecture defines error handling strategy, test utilities have clear messages, test fixtures now consistent with architecture
- **Weaknesses**: No source code to review yet, no user-facing message standards

**Next Steps**:

1. ✅ Fix test fixture inconsistency - **COMPLETED** (updated to use architecture-defined format)
2. Ensure Phase 2 conversion follows error message standards
3. Implement error message validation as code is added
4. Create user-facing error message standards when Telegram integration is implemented

## Related Tasks

- Previous: PHASE4-011
- Next: PHASE4-013

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
