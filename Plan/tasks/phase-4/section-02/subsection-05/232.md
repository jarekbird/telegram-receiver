# PHASE4-014: Check for proper comments where needed

**Section**: 2. Manual Code Review
**Subsection**: 2.5
**Task ID**: PHASE4-014

## Description

Review code comments throughout the codebase to improve code quality and maintainability. This task focuses on auditing actual comment implementation in the source code, verifying commenting best practices are followed, identifying inconsistencies, and ensuring comments meet quality standards. Comments should explain "why" rather than "what", provide context for complex logic, and follow consistent formatting standards.

## Context

This task is distinct from:

- **PHASE4-011**: Check for proper documentation (focused on README files, API docs, architecture docs)
- **PHASE4-013**: Review logging statements (focused on logging, not comments)
- **PHASE4-015**: Verify code readability (focused on code structure, not comments)

**PHASE4-014** focuses specifically on:

- Auditing inline code comments and JSDoc comments in source files
- Verifying comments follow established patterns and best practices
- Identifying missing comments where they would add value
- Ensuring comments explain rationale, not implementation details
- Removing outdated or incorrect comments
- Establishing commenting standards for the codebase

## Comment Types to Review

1. **JSDoc Comments** - Function/class documentation comments
   - Should describe purpose, parameters, return values, exceptions
   - Should follow JSDoc format standards
   - Should be present for all public APIs

2. **Inline Comments** - Explanatory comments within code
   - Should explain "why" not "what"
   - Should clarify complex logic or non-obvious decisions
   - Should not duplicate what the code already makes clear

3. **TODO Comments** - Future work markers
   - Should include context and rationale
   - Should include issue/ticket references if applicable
   - Should have clear ownership or timeline

4. **FIXME Comments** - Known issues or bugs
   - Should explain the issue clearly
   - Should include workaround if applicable
   - Should reference bug tracker if available

5. **Section Comments** - Comments organizing code sections
   - Should help navigate large files
   - Should be consistent in format

## Architecture Reference

The application should follow TypeScript/JavaScript commenting standards:

- **JSDoc format** for function and class documentation
- **Inline comments** for complex logic explanations
- **Consistent comment style** across the codebase
- **No redundant comments** that just restate the code

Reference files:

- `tests/helpers/testUtils.ts` - Example of good JSDoc comments
- `tests/helpers/apiHelpers.ts` - Example of good JSDoc comments
- `docs/architecture.md` - Architecture documentation

## Checklist

- [ ] Review JSDoc comment coverage
  - [ ] Search for all exported functions and verify JSDoc comments exist
  - [ ] Search for all exported classes and verify JSDoc comments exist
  - [ ] Search for all exported interfaces/types and verify JSDoc comments exist
  - [ ] Verify JSDoc comments include @param tags for all parameters
  - [ ] Verify JSDoc comments include @returns tags for return values
  - [ ] Verify JSDoc comments include @throws tags for exceptions
  - [ ] Check JSDoc comment format consistency (/\*_ vs /_)
  - [ ] Verify JSDoc comments are accurate and match implementation

- [ ] Review inline comment quality
  - [ ] Search for all inline comments (// and /\* \*/)
  - [ ] Verify comments explain "why" not "what"
  - [ ] Check for comments that just restate the code (remove these)
  - [ ] Verify comments clarify complex logic or non-obvious decisions
  - [ ] Check for comments that provide context or background information
  - [ ] Review comment formatting consistency
  - [ ] Verify comments are grammatically correct and clear

- [ ] Review TODO comments
  - [ ] Search for all TODO comments in the codebase
  - [ ] Verify each TODO includes context about what needs to be done
  - [ ] Check if TODOs reference issues or tickets
  - [ ] Verify TODOs are still relevant (not outdated)
  - [ ] Check if TODOs have clear ownership or timeline
  - [ ] Document TODOs that need to be addressed
  - [ ] Consider removing or updating outdated TODOs

- [ ] Review FIXME comments
  - [ ] Search for all FIXME comments in the codebase
  - [ ] Verify each FIXME explains the issue clearly
  - [ ] Check if FIXMEs include workarounds or temporary solutions
  - [ ] Verify FIXMEs reference bug trackers if applicable
  - [ ] Check if FIXMEs are still relevant
  - [ ] Document FIXMEs that need to be addressed
  - [ ] Consider creating issues for FIXMEs that need fixes

- [ ] Review comment formatting and style
  - [ ] Check for consistent comment style (// vs /\* \*/)
  - [ ] Verify comment indentation matches code indentation
  - [ ] Check for consistent spacing around comments
  - [ ] Verify multi-line comments use proper formatting
  - [ ] Check for consistent capitalization in comments
  - [ ] Review comment length (not too long, not too short)

- [ ] Identify missing comments
  - [ ] Review complex functions for missing explanatory comments
  - [ ] Check for complex algorithms that need comments
  - [ ] Review non-obvious code that would benefit from comments
  - [ ] Check for business logic that needs context comments
  - [ ] Review error handling that might need explanation
  - [ ] Check for workarounds or hacks that need comments
  - [ ] Verify public APIs have proper JSDoc comments

- [ ] Remove outdated comments
  - [ ] Search for comments that reference old code or removed features
  - [ ] Check for comments that no longer match the implementation
  - [ ] Verify comments are still accurate
  - [ ] Remove comments for code that has been refactored
  - [ ] Update comments that reference outdated patterns

- [ ] Review comment quality standards
  - [ ] Verify comments use clear, concise language
  - [ ] Check for spelling and grammar errors in comments
  - [ ] Verify comments are written in English (or project standard language)
  - [ ] Check for comments that are too verbose or too terse
  - [ ] Review comments for clarity and readability

- [ ] Check for comment-related code smells
  - [ ] Identify code that needs comments because it's too complex (consider refactoring)
  - [ ] Check for commented-out code (should be removed, not commented)
  - [ ] Review for excessive comments (code should be self-documenting)
  - [ ] Check for comments that indicate missing abstractions
  - [ ] Verify comments don't mask code quality issues

- [ ] Document commenting standards
  - [ ] Create or update commenting style guide
  - [ ] Document when comments are required vs optional
  - [ ] Create examples of good comments
  - [ ] Document JSDoc format standards
  - [ ] Create examples of bad comments (what to avoid)
  - [ ] Document commenting best practices specific to this codebase
  - [ ] Update architecture documentation if needed

- [ ] Review test file comments
  - [ ] Check test files for appropriate comments
  - [ ] Verify test descriptions are clear (test names should be descriptive)
  - [ ] Review comments explaining test setup or teardown
  - [ ] Check for comments explaining complex test scenarios
  - [ ] Verify mock/stub comments are clear

- [ ] Review configuration file comments
  - [ ] Check config files for explanatory comments
  - [ ] Verify environment-specific settings have comments
  - [ ] Review comments explaining configuration options
  - [ ] Check for comments explaining default values

## Notes

- This task is part of Phase 4: Code Quality Audit
- Section: 2. Manual Code Review
- Focus on identifying and fixing code quality issues
- Document all findings and improvements

- Task can be completed independently by a single agent

- **Current Codebase State**: As of evaluation, the codebase is in early development with minimal source code implemented. The `src/` directory is mostly empty (only `.gitkeep` files), and the primary code exists in test files (`tests/`). When reviewing comments:
  - Focus on test files, configuration files, and any existing source files
  - Some checklist items may have limited applicability until Phase 2 conversion is complete
  - Document findings and recommendations for future code that will be added during Phase 2
  - Establish commenting standards that will apply to all future code

## Related Tasks

- Previous: PHASE4-013
- Next: PHASE4-015

---

IMPORTANT: When updating system settings (SystemSetting model), you MUST use the cursor-runner-shared-sqlite MCP connection.

IMPORTANT: When working with tasks (creating, querying, updating, or deleting tasks), you MUST use the cursor-runner-shared-sqlite MCP connection. The tasks table is in the shared SQLite database at /app/shared_db/shared.sqlite3.

Tasks Table Schema:

- id: INTEGER PRIMARY KEY AUTOINCREMENT
- prompt: TEXT NOT NULL (the task prompt/description to be executed)
- status: INTEGER NOT NULL DEFAULT 0 (task status enum: 0=ready, 1=complete, 2=archived, 3=backlogged)
- createdat: DATETIME DEFAULT CURRENT_TIMESTAMP
- updatedat: DATETIME DEFAULT CURRENT_TIMESTAMP
- order: INTEGER DEFAULT 0 (lower numbers are processed first)
- uuid: TEXT (unique identifier, indexed)

Task Status Values:

- 0 = ready (ready to be processed by task operator)
- 1 = complete (task has been completed)
- 2 = archived (task has been archived)
- 3 = backlogged (task is in backlog, not ready for processing)

Task Management Examples:

- To create a ready task: INSERT INTO tasks (prompt, "order", status) VALUES ('your prompt here', 0, 0)
- To list ready tasks: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC
- To mark a task as complete: UPDATE tasks SET status = 1, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To archive a task: UPDATE tasks SET status = 2, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To backlog a task: UPDATE tasks SET status = 3, updatedat = CURRENT_TIMESTAMP WHERE id = ?
- To get next ready task: SELECT \* FROM tasks WHERE status = 0 ORDER BY "order" ASC, id ASC LIMIT 1

The task operator agent (when enabled) automatically processes tasks with status = 0 (ready), sending the prompt to cursor-runner for execution.

IMPORTANT: When working with cursor-agents (creating, listing, getting status, or deleting agents), use the Python scripts in /cursor/tools/cursor-agents/ directory. These scripts communicate with the cursor-agents service over HTTP:

Agent Management:

- To list all agents: python3 /cursor/tools/cursor-agents/list_agents.py
- To get agent status: python3 /cursor/tools/cursor-agents/get_agent_status.py --name <agent-name>
- To create an agent: python3 /cursor/tools/cursor-agents/create_agent.py --name <name> --target-url <url> [options]
  - Use --queue <queue-name> to assign the agent to a specific queue (defaults to "default" if not specified)
  - Use --schedule <cron-pattern> for recurring agents (e.g., "0 8 \* \* \*" for daily at 8 AM)
  - Use --one-time for one-time agents that run immediately
- To delete an agent: python3 /cursor/tools/cursor-agents/delete_agent.py --name <agent-name>

Queue Management:

- To list all queues: python3 /cursor/tools/cursor-agents/list_queues.py
- To get queue info: python3 /cursor/tools/cursor-agents/get_queue_info.py --queue-name <queue-name>
- To delete an empty queue: python3 /cursor/tools/cursor-agents/delete_queue.py --queue-name <queue-name>
  - Note: Cannot delete the "default" queue or queues with active jobs

Task Operator Management:

- To enable the task operator: python3 /cursor/tools/cursor-agents/enable_task_operator.py [--queue <queue-name>]
  - The task operator automatically processes tasks from the tasks table in the database
  - It checks for incomplete tasks (lowest order first) and sends them to cursor-runner
  - Automatically re-enqueues itself every 5 seconds while enabled
- To disable the task operator: python3 /cursor/tools/cursor-agents/disable_task_operator.py
  - Sets the task_operator system setting to false, stopping re-enqueueing

When creating an agent, the target URL should be the cursor-runner docker networked URL (http://cursor-runner:3001/cursor/iterate/async) with a prompt that this agent will later execute.

Queue Organization: Agents can be organized into queues to avoid queue bloat. By default, agents are created in the "default" queue. Use descriptive queue names like "daily-tasks", "hourly-sync", or "urgent-jobs" to group related agents together.

IMPORTANT: When creating one-time scripts (shell scripts, Python scripts, etc.), place them in /cursor/scripts. This directory is shared and persistent across container restarts. Do not create scripts in the repository directories or other temporary locations.
